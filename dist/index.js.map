{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9qEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClpBA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7mEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../avrolint.js","../node_modules/@actions/core/lib/command.js","../node_modules/@actions/core/lib/core.js","../node_modules/@actions/core/lib/file-command.js","../node_modules/@actions/core/lib/oidc-utils.js","../node_modules/@actions/core/lib/path-utils.js","../node_modules/@actions/core/lib/summary.js","../node_modules/@actions/core/lib/utils.js","../node_modules/@actions/http-client/lib/auth.js","../node_modules/@actions/http-client/lib/index.js","../node_modules/@actions/http-client/lib/proxy.js","../node_modules/avro-js/etc/deprecated/validator.js","../node_modules/avro-js/lib/files.js","../node_modules/avro-js/lib/index.js","../node_modules/avro-js/lib/protocols.js","../node_modules/avro-js/lib/schemas.js","../node_modules/avro-js/lib/utils.js","../node_modules/tunnel/index.js","../node_modules/tunnel/lib/tunnel.js","../node_modules/uuid/dist/index.js","../node_modules/uuid/dist/md5.js","../node_modules/uuid/dist/nil.js","../node_modules/uuid/dist/parse.js","../node_modules/uuid/dist/regex.js","../node_modules/uuid/dist/rng.js","../node_modules/uuid/dist/sha1.js","../node_modules/uuid/dist/stringify.js","../node_modules/uuid/dist/v1.js","../node_modules/uuid/dist/v3.js","../node_modules/uuid/dist/v35.js","../node_modules/uuid/dist/v4.js","../node_modules/uuid/dist/v5.js","../node_modules/uuid/dist/validate.js","../node_modules/uuid/dist/version.js","../node:node-commonjs \"assert\"","../node:node-commonjs \"buffer\"","../node:node-commonjs \"crypto\"","../node:node-commonjs \"events\"","../node:node-commonjs \"fs\"","../node:node-commonjs \"http\"","../node:node-commonjs \"https\"","../node:node-commonjs \"net\"","../node:node-commonjs \"os\"","../node:node-commonjs \"path\"","../node:node-commonjs \"stream\"","../node:node-commonjs \"tls\"","../node:node-commonjs \"util\"","../node:node-commonjs \"zlib\"","../node_modules/underscore/underscore-node-f.cjs","../node_modules/underscore/underscore-node.cjs","/webpack/bootstrap","/webpack/runtime/compat","../index.js"],"sourcesContent":["const fs = require('fs')\nconst core = require('@actions/core');\nconst avro = require('avro-js');\n\nlet avrolint = function(avscFilePath, options={\"undocumentedCheck\": true, \"complexUnionCheck\": true}) {\n  return new Promise((resolve) => {\n    // default, assume input is single file\n    var filePaths = [avscFilePath];\n\t\ttry {\n      // try to see if it's a list of paths in JSON array\n      filePaths = JSON.parse(avscFilePath);\n    }\n    catch (err) {\n\t\t\t// ignore\n    }\n\n    var filePathsWithErrors = [];\n\t\tfor (const filePath of filePaths) {\n      if (typeof filePath === 'undefined' || !fs.existsSync(filePath)) {\n        if (typeof filePath === 'undefined') {\n          filePathsWithErrors.push(\"undefined\"); // without this a blank error message is printed\n        } else {\n          filePathsWithErrors.push(filePath);\n        }\n        core.error(\"avscFilePath is invalid: '\" + filePath + \"'\");\n        continue;\n      }\n\n      var fileContents = fs.readFileSync(filePath);\n      var avroSchemaJson;\n\n      try {\n        avroSchemaJson = JSON.parse(fileContents);\n      } catch (err) {\n        filePathsWithErrors.push(filePath);\n        core.error(\"AVSC file specified is not valid/parseable JSON: \" + filePath + \"\\n  \" + err.toString());\n        continue;\n      }\n\n      var avroType;\n      try {\n        avroType = avro.parse(avroSchemaJson);\n      } catch (err) {\n        filePathsWithErrors.push(filePath);\n        core.error(\"AVSC file specified is not valid/parseable: \" + filePath + \"\\n  \" + err.toString());\n        continue;\n      }\n\n      if (options.undocumentedCheck) {\n        const undocumentedFields = getUndocumentedFields(avroType.getName(), avroSchemaJson);\n        if (undocumentedFields.length > 0) {\n          filePathsWithErrors.push(filePath);\n          const errorMessage = `Invalid Schema at '${filePath}'! The following fields are not documented:`;\n          core.error(errorMessage.concat(\"\\n  \", ...undocumentedFields.join(\"\\n  \")));\n        }\n      }\n\n      if (options.complexUnionCheck) {\n        const complexUnionFields = getComplexUnionFields(avroType.getName(), avroSchemaJson);\n        if (complexUnionFields.length > 0) {\n          filePathsWithErrors.push(filePath);\n          const errorMessage = `Invalid Schema at '${filePath}'! The following fields are or contain complex unions:`;\n          core.error(errorMessage.concat(\"\\n  \", ...complexUnionFields.join(\"\\n  \")));\n        }\n      }\n    }\n\n    if (filePathsWithErrors.length > 0) {\n      const errorMessage = \"Validation failed for the following files:\";\n      throw new Error(errorMessage.concat(\"\\n  \", ...filePathsWithErrors.join(\"\\n  \")));\n    }\n\n    resolve(\"done!\");\n  });\n};\n\nlet isOrContainsRecord = function(field) {\n\tif (Array.isArray(field.type)) {\n    // Check UNION type for RECORD type\n    return field.type.filter(x => x.type?.toUpperCase() === \"RECORD\").length > 0;\n  }\n\n  const upperCaseFieldType = field.type.type?.toUpperCase();\n  if (upperCaseFieldType === \"RECORD\") {\n    return true;\n  } else if (upperCaseFieldType === \"ARRAY\" && field.type.items?.type?.toUpperCase() === \"RECORD\") {\n    return true;\n  } else if (upperCaseFieldType === \"MAP\" && field.type.values?.type?.toUpperCase() === \"RECORD\") {\n    return true;\n  }\n\n  return false;\n}\n\nlet isUnionType = function(type) {\n\treturn Array.isArray(type);\n}\n\nlet getRecordSchema = function(field) {\n  if (isUnionType(field.type)) {\n    // Extract UNION type RECORD schema\n    return field.type.filter(x => x.type?.toUpperCase() === \"RECORD\")[0];\n  }\n\n  const upperCaseFieldType = field.type.type?.toUpperCase();\n  if (upperCaseFieldType === \"RECORD\") {\n    return field;\n  } else if (upperCaseFieldType === \"ARRAY\" && field.type.items?.type?.toUpperCase() === \"RECORD\") {\n    return field.type.items;\n  } else if (upperCaseFieldType === \"MAP\" && field.type.values?.type?.toUpperCase() === \"RECORD\") {\n    return field.type.values;\n  }\n}\n\nlet getUndocumentedFields = function(pathPrefix, avroSchemaJson) {\n  const undocumentedFields = [];\n\n  for (const field of avroSchemaJson.fields) {\n    if (field.doc == null || field.doc.trim() === '') {\n      undocumentedFields.push(pathPrefix + '.' + field.name);\n    }\n    if (isOrContainsRecord(field)) {\n      undocumentedFields.push(...getUndocumentedFields(pathPrefix + '.' + field.name, getRecordSchema(field)));\n    }\n  }\n\n  return undocumentedFields;\n}\n\nlet getUnionSchema = function(field) {\n\n  if (isUnionType(field.type)) {\n    return field.type;\n  }\n\n\tconst upperCaseFieldType = field.type.type?.toUpperCase();\n\tif (upperCaseFieldType === \"ARRAY\" && isUnionType(field.type.items)) {\n    return field.type.items;\n  } else if (upperCaseFieldType === \"MAP\" && isUnionType(field.type.values)) {\n    return field.type.values;\n  }\n\n}\n\nlet isComplexUnion = function(field) {\n\tconst unionSchema = getUnionSchema(field);\n\n\tif (!unionSchema) {\n    return false;\n  }\n\n\tif (unionSchema.length == 2 && unionSchema[0].toUpperCase() === \"NULL\") {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nlet getComplexUnionFields = function(pathPrefix, avroSchemaJson) {\n  const complexUnionFields = [];\n\n  for (const field of avroSchemaJson.fields) {\n    if (isComplexUnion(field)) {\n      complexUnionFields.push(pathPrefix + '.' + field.name);\n\t\t}\n\n\t\tif (isOrContainsRecord(field)) {\n      complexUnionFields.push(...getComplexUnionFields(pathPrefix + '.' + field.name, getRecordSchema(field)));\n\t\t}\n\t}\n\n  return complexUnionFields;\n}\n\nmodule.exports = avrolint;\n\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));\n    }\n    command_1.issueCommand('set-env', { name }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueFileCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    if (options && options.trimWhitespace === false) {\n        return inputs;\n    }\n    return inputs.map(input => input.trim());\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    const filePath = process.env['GITHUB_OUTPUT'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    const filePath = process.env['GITHUB_STATE'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */\nvar summary_1 = require(\"./summary\");\nObject.defineProperty(exports, \"summary\", { enumerable: true, get: function () { return summary_1.summary; } });\n/**\n * @deprecated use core.summary\n */\nvar summary_2 = require(\"./summary\");\nObject.defineProperty(exports, \"markdownSummary\", { enumerable: true, get: function () { return summary_2.markdownSummary; } });\n/**\n * Path exports\n */\nvar path_utils_1 = require(\"./path-utils\");\nObject.defineProperty(exports, \"toPosixPath\", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });\nObject.defineProperty(exports, \"toWin32Path\", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });\nObject.defineProperty(exports, \"toPlatformPath\", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepareKeyValueMessage = exports.issueFileCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst uuid_1 = require(\"uuid\");\nconst utils_1 = require(\"./utils\");\nfunction issueFileCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueFileCommand = issueFileCommand;\nfunction prepareKeyValueMessage(key, value) {\n    const delimiter = `ghadelimiter_${uuid_1.v4()}`;\n    const convertedValue = utils_1.toCommandValue(value);\n    // These should realistically never happen, but just in case someone finds a\n    // way to exploit uuid generation let's not allow keys or values that contain\n    // the delimiter.\n    if (key.includes(delimiter)) {\n        throw new Error(`Unexpected input: name should not contain the delimiter \"${delimiter}\"`);\n    }\n    if (convertedValue.includes(delimiter)) {\n        throw new Error(`Unexpected input: value should not contain the delimiter \"${delimiter}\"`);\n    }\n    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;\n}\nexports.prepareKeyValueMessage = prepareKeyValueMessage;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/lib/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * toPosixPath converts the given path to the posix form. On Windows, \\\\ will be\n * replaced with /.\n *\n * @param pth. Path to transform.\n * @return string Posix path.\n */\nfunction toPosixPath(pth) {\n    return pth.replace(/[\\\\]/g, '/');\n}\nexports.toPosixPath = toPosixPath;\n/**\n * toWin32Path converts the given path to the win32 form. On Linux, / will be\n * replaced with \\\\.\n *\n * @param pth. Path to transform.\n * @return string Win32 path.\n */\nfunction toWin32Path(pth) {\n    return pth.replace(/[/]/g, '\\\\');\n}\nexports.toWin32Path = toWin32Path;\n/**\n * toPlatformPath converts the given path to a platform-specific path. It does\n * this by replacing instances of / and \\ with the platform-specific path\n * separator.\n *\n * @param pth The path to platformize.\n * @return string The platform-specific path.\n */\nfunction toPlatformPath(pth) {\n    return pth.replace(/[/\\\\]/g, path.sep);\n}\nexports.toPlatformPath = toPlatformPath;\n//# sourceMappingURL=path-utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"os\");\nconst fs_1 = require(\"fs\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor() {\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */\n    filePath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._filePath) {\n                return this._filePath;\n            }\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) {\n                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            }\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            }\n            catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */\n    wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs)\n            .map(([key, value]) => ` ${key}=\"${value}\"`)\n            .join('');\n        if (!content) {\n            return `<${tag}${htmlAttrs}>`;\n        }\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.emptyBuffer().write({ overwrite: true });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */\n    stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */\n    isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */\n    addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, (lang && { lang }));\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map(item => this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */\n    addTable(rows) {\n        const tableBody = rows\n            .map(row => {\n            const cells = row\n                .map(cell => {\n                if (typeof cell === 'string') {\n                    return this.wrap('td', cell);\n                }\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));\n                return this.wrap(tag, data, attrs);\n            })\n                .join('');\n            return this.wrap('tr', cells);\n        })\n            .join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */\n    addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */\n    addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));\n        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */\n    addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n            ? tag\n            : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */\n    addQuote(text, cite) {\n        const attrs = Object.assign({}, (cite && { cite }));\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */\n    addLink(text, href) {\n        const element = this.wrap('a', text, { href });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */\nexports.markdownSummary = _summary;\nexports.summary = _summary;\n//# sourceMappingURL=summary.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceMappingURL=auth.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(require(\"http\"));\nconst https = __importStar(require(\"https\"));\nconst pm = __importStar(require(\"./proxy\"));\nconst tunnel = __importStar(require(\"tunnel\"));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on('data', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on('end', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('GET', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('POST', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PUT', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error('Client has already been disposed.');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it's an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers['location'];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === 'https:' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === 'authorization') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error('Unknown error'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === 'string') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === 'string') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        return new URL(proxyVar);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n//# sourceMappingURL=proxy.js.map","// Licensed to the Apache Software Foundation (ASF) under one or more\n// contributor license agreements.  See the NOTICE file distributed with\n// this work for additional information regarding copyright ownership.\n// The ASF licenses this file to You under the Apache License, Version 2.0\n// (the \"License\"); you may not use this file except in compliance with\n// the License.  You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _ = require(\"underscore\"),\n    util = require('util');\n\nvar WARNING = 'Validator API is deprecated. Please use the type API instead.';\nValidator = util.deprecate(Validator, WARNING);\nProtocolValidator = util.deprecate(ProtocolValidator, WARNING);\n\nvar AvroSpec = {\n  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],\n  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']\n};\nAvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);\n\nvar InvalidSchemaError = function(msg) { return new Error('InvalidSchemaError: ' + msg); };\nvar InvalidProtocolError = function(msg) { return new Error('InvalidProtocolError: ' + msg); };\nvar ValidationError = function(msg) { return new Error('ValidationError: ' + msg); };\nvar ProtocolValidationError = function(msg) { return new Error('ProtocolValidationError: ' + msg); };\n\n\nfunction Record(name, namespace, fields) {\n  function validateArgs(name, namespace, fields) {\n    if (!_.isString(name)) {\n      throw new InvalidSchemaError('Record name must be string');\n    }\n\n    if (!_.isNull(namespace) && !_.isUndefined(namespace) && !_.isString(namespace)) {\n      throw new InvalidSchemaError('Record namespace must be string or null');\n    }\n\n    if (!_.isArray(fields)) {\n      throw new InvalidSchemaError('Record name must be string');\n    }\n  }\n\n  validateArgs(name, namespace, fields);\n\n  this.name = name;\n  this.namespace = namespace;\n  this.fields = fields;\n}\n\nfunction makeFullyQualifiedTypeName(schema, namespace) {\n  var typeName = null;\n  if (_.isString(schema)) {\n    typeName = schema;\n  } else if (_.isObject(schema)) {\n    if (_.isString(schema.namespace)) {\n      namespace = schema.namespace;\n    }\n    if (_.isString(schema.name)) {\n      typeName = schema.name;\n    } else if (_.isString(schema.type)) {\n      typeName = schema.type;\n    }\n  } else {\n    throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);\n  }\n\n  if (!_.isString(typeName)) {\n    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);\n  }\n\n  if (typeName.indexOf('.') !== -1) {\n    return typeName;\n  } else if (_.contains(AvroSpec.PrimitiveTypes, typeName)) {\n    return typeName;\n  } else if (_.isString(namespace)) {\n    return namespace + '.' + typeName;\n  } else {\n    return typeName;\n  }\n}\n\nfunction Union(typeSchemas, namespace) {\n  this.branchNames = function() {\n    return _.map(typeSchemas, function(typeSchema) { return makeFullyQualifiedTypeName(typeSchema, namespace); });\n  };\n\n  function validateArgs(typeSchemas) {\n    if (!_.isArray(typeSchemas) || _.isEmpty(typeSchemas)) {\n      throw new InvalidSchemaError('Union must have at least 1 branch');\n    }\n  }\n\n  validateArgs(typeSchemas);\n\n  this.typeSchemas = typeSchemas;\n  this.namespace = namespace;\n}\n\nfunction Enum(symbols) {\n\n  function validateArgs(symbols) {\n    if (!_.isArray(symbols)) {\n      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));\n    }\n    if (!_.all(symbols, function(symbol) { return _.isString(symbol); })) {\n      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));\n    }\n  }\n\n  validateArgs(symbols);\n\n  this.symbols = symbols;\n}\n\nfunction AvroArray(itemSchema) {\n\n  function validateArgs(itemSchema) {\n    if (_.isNull(itemSchema) || _.isUndefined(itemSchema)) {\n      throw new InvalidSchemaError('Array \"items\" schema should not be null or undefined');\n    }\n  }\n\n  validateArgs(itemSchema);\n\n  this.itemSchema = itemSchema;\n}\n\nfunction Map(valueSchema) {\n\n  function validateArgs(valueSchema) {\n    if (_.isNull(valueSchema) || _.isUndefined(valueSchema)) {\n      throw new InvalidSchemaError('Map \"values\" schema should not be null or undefined');\n    }\n  }\n\n  validateArgs(valueSchema);\n\n  this.valueSchema = valueSchema;\n}\n\nfunction Field(name, schema) {\n  function validateArgs(name, schema) {\n    if (!_.isString(name)) {\n      throw new InvalidSchemaError('Field name must be string');\n    }\n  }\n\n  this.name = name;\n  this.schema = schema;\n}\n\nfunction Primitive(type) {\n  function validateArgs(type) {\n    if (!_.isString(type)) {\n      throw new InvalidSchemaError('Primitive type name must be a string');\n    }\n\n    if (!_.contains(AvroSpec.PrimitiveTypes, type)) {\n      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);\n    }\n  }\n\n  validateArgs(type);\n\n  this.type = type;\n}\n\nfunction Validator(schema, namespace, namedTypes) {\n  this.validate = function(obj) {\n    return _validate(this.schema, obj);\n  };\n\n  var _validate = function(schema, obj) {\n    if (schema instanceof Record) {\n      return _validateRecord(schema, obj);\n    } else if (schema instanceof Union) {\n      return _validateUnion(schema, obj);\n    } else if (schema instanceof Enum) {\n      return _validateEnum(schema, obj);\n    } else if (schema instanceof AvroArray) {\n      return _validateArray(schema, obj);\n    } else if (schema instanceof Map) {\n      return _validateMap(schema, obj);\n    } else if (schema instanceof Primitive) {\n      return _validatePrimitive(schema, obj);\n    } else {\n      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));\n    }\n  };\n\n  var _validateRecord = function(schema, obj) {\n    if (!_.isObject(obj) || _.isArray(obj)) {\n      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));\n    }\n\n    var schemaFieldNames = _.pluck(schema.fields, 'name').sort();\n    var objFieldNames = _.keys(obj).sort();\n    if (!_.isEqual(schemaFieldNames, objFieldNames)) {\n      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));\n    }\n\n    return _.all(schema.fields, function(field) {\n      return _validate(field.schema, obj[field.name]);\n    });\n  };\n\n  var _validateUnion = function(schema, obj) {\n    if (_.isObject(obj)) {\n      if (_.isArray(obj)) {\n        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));\n      } else if (_.size(obj) !== 1) {\n        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));\n      } else {\n        var unionBranch = _.keys(obj)[0];\n        if (unionBranch === \"\") {\n          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));\n        }\n        if (_.contains(schema.branchNames(), unionBranch)) {\n          return true;\n        } else {\n          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));\n        }\n      }\n    } else if (_.isNull(obj)) {\n      if (_.contains(schema.branchNames(), 'null')) {\n        return true;\n      } else {\n        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));\n      }\n    } else {\n      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));\n    }\n  };\n\n  var _validateEnum = function(schema, obj) {\n    if (_.isString(obj)) {\n      if (_.contains(schema.symbols, obj)) {\n        return true;\n      } else {\n        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));\n      }\n    } else {\n      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));\n    }\n  };\n\n  var _validateArray = function(schema, obj) {\n    if (_.isArray(obj)) {\n      return _.all(obj, function(member) { return _validate(schema.itemSchema, member); });\n    } else {\n      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));\n    }\n  };\n\n  var _validateMap = function(schema, obj) {\n    if (_.isObject(obj) && !_.isArray(obj)) {\n      return _.all(obj, function(value) { return _validate(schema.valueSchema, value); });\n    } else if (_.isArray(obj)) {\n      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));\n    } else {\n      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));\n    }\n  };\n\n  var _validatePrimitive = function(schema, obj) {\n    switch (schema.type) {\n      case 'null':\n        if (_.isNull(obj) || _.isUndefined(obj)) {\n          return true;\n        } else {\n          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));\n        }\n        break;\n      case 'boolean':\n        if (_.isBoolean(obj)) {\n          return true;\n        } else {\n          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));\n        }\n        break;\n      case 'int':\n        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {\n          return true;\n        } else {\n          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));\n        }\n        break;\n      case 'long':\n        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {\n          return true;\n        } else {\n          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));\n        }\n        break;\n      case 'float':\n        if (_.isNumber(obj)) { // TODO: handle NaN?\n          return true;\n        } else {\n          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));\n        }\n        break;\n      case 'double':\n        if (_.isNumber(obj)) { // TODO: handle NaN?\n          return true;\n        } else {\n          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));\n        }\n        break;\n      case 'bytes':\n        throw new InvalidSchemaError('not yet implemented: ' + schema.type);\n      case 'string':\n        if (_.isString(obj)) { // TODO: handle NaN?\n          return true;\n        } else {\n          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));\n        }\n        break;\n      default:\n        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);\n    }\n  };\n\n  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition\n  // are probably buggy.\n  var _namedTypes = namedTypes || {};\n  var _saveNamedType = function(fullyQualifiedTypeName, schema) {\n    if (_.has(_namedTypes, fullyQualifiedTypeName)) {\n      if (!_.isEqual(_namedTypes[fullyQualifiedTypeName], schema)) {\n        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));\n      }\n    } else {\n      _namedTypes[fullyQualifiedTypeName] = schema;\n    }\n  };\n\n  var _lookupTypeByFullyQualifiedName = function(fullyQualifiedTypeName) {\n    if (_.has(_namedTypes, fullyQualifiedTypeName)) {\n      return _namedTypes[fullyQualifiedTypeName];\n    } else {\n      return null;\n    }\n  };\n\n  var _parseNamedType = function(schema, namespace) {\n    if (_.contains(AvroSpec.PrimitiveTypes, schema)) {\n      return new Primitive(schema);\n    } else if (!_.isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {\n      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));\n    } else {\n      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(_.keys(_namedTypes)));\n    }\n  };\n\n  var _parseSchema = function(schema, parentSchema, namespace) {\n    if (_.isNull(schema) || _.isUndefined(schema)) {\n      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));\n    } else if (_.isString(schema)) {\n      return _parseNamedType(schema, namespace);\n    } else if (_.isObject(schema) && !_.isArray(schema)) {\n      if (schema.type === 'record') {\n        var newRecord = new Record(schema.name, schema.namespace, _.map(schema.fields, function(field) {\n          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));\n        }));\n        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);\n        return newRecord;\n      } else if (schema.type === 'enum') {\n        if (_.has(schema, 'symbols')) {\n          var newEnum = new Enum(schema.symbols);\n          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);\n          return newEnum;\n        } else {\n          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));\n        }\n      } else if (schema.type === 'array') {\n        if (_.has(schema, 'items')) {\n          return new AvroArray(_parseSchema(schema.items, schema, namespace));\n        } else {\n          throw new InvalidSchemaError('array must specify \"items\" schema, got ' + JSON.stringify(schema));\n        }\n      } else if (schema.type === 'map') {\n        if (_.has(schema, 'values')) {\n          return new Map(_parseSchema(schema.values, schema, namespace));\n        } else {\n          throw new InvalidSchemaError('map must specify \"values\" schema, got ' + JSON.stringify(schema));\n        }\n      } else if (_.has(schema, 'type') && _.contains(AvroSpec.PrimitiveTypes, schema.type)) {\n        return _parseNamedType(schema.type, namespace);\n      } else {\n        throw new InvalidSchemaError('not yet implemented: ' + schema.type);\n      }\n    } else if (_.isArray(schema)) {\n      if (_.isEmpty(schema)) {\n        throw new InvalidSchemaError('unions must have at least 1 branch');\n      }\n      var branchTypes = _.map(schema, function(branchType) { return _parseSchema(branchType, schema, namespace); });\n      return new Union(branchTypes, namespace);\n    } else {\n      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema));\n    }\n  };\n\n  this.rawSchema = schema;\n  this.schema = _parseSchema(schema, null, namespace);\n}\n\nValidator.validate = function(schema, obj) {\n  return (new Validator(schema)).validate(obj);\n}\n\nfunction ProtocolValidator(protocol) {\n  this.validate = function(typeName, obj) {\n    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);\n    if (!_.has(_typeSchemaValidators, fullyQualifiedTypeName)) {\n      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input \"' + typeName + '\"); known types are ' + JSON.stringify(_.keys(_typeSchemaValidators)));\n    }\n    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);\n  };\n\n  var _typeSchemaValidators = {};\n  var _initSchemaValidators = function(protocol) {\n    var namedTypes = {};\n    if (!_.has(protocol, 'protocol') || !_.isString(protocol.protocol)) {\n      throw new InvalidProtocolError('Protocol must contain a \"protocol\" attribute with a string value');\n    }\n    if (_.isArray(protocol.types)) {\n      _.each(protocol.types, function(typeSchema) {\n        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);\n        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);\n        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;\n      });\n    }\n  };\n\n  _initSchemaValidators(protocol);\n}\n\nProtocolValidator.validate = function(protocol, typeName, obj) {\n  return (new ProtocolValidator(protocol)).validate(typeName, obj);\n};\n\nif (typeof exports !== 'undefined') {\n  exports['Validator'] = Validator;\n  exports['ProtocolValidator'] = ProtocolValidator;\n}\n","/* jshint node: true */\n\n/**\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *  https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\n'use strict';\n\nvar protocols = require('./protocols'),\n    schemas = require('./schemas'),\n    utils = require('./utils'),\n    fs = require('fs'),\n    stream = require('stream'),\n    util = require('util'),\n    path = require('path'),\n    zlib = require('zlib');\n\n// Type of Avro header.\nvar HEADER_TYPE = schemas.createType({\n  type: 'record',\n  name: 'org.apache.avro.file.Header',\n  fields : [\n    {name: 'magic', type: {type: 'fixed', name: 'Magic', size: 4}},\n    {name: 'meta', type: {type: 'map', values: 'bytes'}},\n    {name: 'sync', type: {type: 'fixed', name: 'Sync', size: 16}}\n  ]\n});\n\n// Type of each block.\nvar BLOCK_TYPE = schemas.createType({\n  type: 'record',\n  name: 'org.apache.avro.file.Block',\n  fields : [\n    {name: 'count', type: 'long'},\n    {name: 'data', type: 'bytes'},\n    {name: 'sync', type: {type: 'fixed', name: 'Sync', size: 16}}\n  ]\n});\n\n// Used to toBuffer each block, without having to copy all its data.\nvar LONG_TYPE = schemas.createType('long');\n\n// First 4 bytes of an Avro object container file.\nvar MAGIC_BYTES = Buffer.from('Obj\\x01');\n\n// Convenience.\nvar f = util.format;\nvar Tap = utils.Tap;\n\n\n/**\n * Parse a schema and return the corresponding type.\n *\n */\nfunction parse(schema, opts) {\n  var attrs = loadSchema(schema);\n  return attrs.protocol ?\n    protocols.createProtocol(attrs, opts) :\n    schemas.createType(attrs, opts);\n}\n\n\n/**\n * Duplex stream for decoding fragments.\n *\n */\nfunction RawDecoder(schema, opts) {\n  opts = opts || {};\n\n  var decode = opts.decode === undefined ? true : !!opts.decode;\n  stream.Duplex.call(this, {\n    readableObjectMode: decode,\n    allowHalfOpen: false\n  });\n  // Somehow setting this to false only closes the writable side after the\n  // readable side ends, while we need the other way. So we do it manually.\n\n  this._type = parse(schema);\n  this._tap = new Tap(Buffer.alloc(0));\n  this._needPush = false;\n  this._readValue = createReader(decode, this._type);\n  this._finished = false;\n\n  this.on('finish', function () {\n    this._finished = true;\n    this._read();\n  });\n}\nutil.inherits(RawDecoder, stream.Duplex);\n\nRawDecoder.prototype._write = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n  if (this._needPush) {\n    this._needPush = false;\n    this._read();\n  }\n  cb();\n};\n\nRawDecoder.prototype._read = function () {\n  var tap = this._tap;\n  var pos = tap.pos;\n  var val = this._readValue(tap);\n  if (tap.isValid()) {\n    this.push(val);\n  } else if (!this._finished) {\n    tap.pos = pos;\n    this._needPush = true;\n  } else {\n    this.push(null);\n  }\n};\n\n\n/**\n * Duplex stream for decoding object container files.\n *\n */\nfunction BlockDecoder(opts) {\n  opts = opts || {};\n\n  var decode = opts.decode === undefined ? true : !!opts.decode;\n  stream.Duplex.call(this, {\n    allowHalfOpen: true, // For async decompressors.\n    readableObjectMode: decode\n  });\n\n  this._type = null;\n  this._codecs = opts.codecs;\n  this._parseOpts = opts.parseOpts || {};\n  this._tap = new Tap(Buffer.alloc(0));\n  this._blockTap = new Tap(Buffer.alloc(0));\n  this._syncMarker = null;\n  this._readValue = null;\n  this._decode = decode;\n  this._queue = new utils.OrderedQueue();\n  this._decompress = null; // Decompression function.\n  this._index = 0; // Next block index.\n  this._pending = 0; // Number of blocks undergoing decompression.\n  this._needPush = false;\n  this._finished = false;\n\n  this.on('finish', function () {\n    this._finished = true;\n    if (!this._pending) {\n      this.push(null);\n    }\n  });\n}\nutil.inherits(BlockDecoder, stream.Duplex);\n\nBlockDecoder.getDefaultCodecs = function () {\n  return {\n    'null': function (buf, cb) { cb(null, buf); },\n    'deflate': zlib.inflateRaw\n  };\n};\n\nBlockDecoder.prototype._decodeHeader = function () {\n  var tap = this._tap;\n  var header = HEADER_TYPE._read(tap);\n  if (!tap.isValid()) {\n    // Wait until more data arrives.\n    return false;\n  }\n\n  if (!MAGIC_BYTES.equals(header.magic)) {\n    this.emit('error', new Error('invalid magic bytes'));\n    return;\n  }\n\n  var codec = (header.meta['avro.codec'] || 'null').toString();\n  this._decompress = (this._codecs || BlockDecoder.getDefaultCodecs())[codec];\n  if (!this._decompress) {\n    this.emit('error', new Error(f('unknown codec: %s', codec)));\n    return;\n  }\n\n  try {\n    var schema = JSON.parse(header.meta['avro.schema'].toString());\n    this._type = parse(schema, this._parseOpts);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n\n  this._readValue = createReader(this._decode, this._type);\n  this._syncMarker = header.sync;\n  this.emit('metadata', this._type, codec, header);\n  return true;\n};\n\nBlockDecoder.prototype._write = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf, chunk]);\n  tap.pos = 0;\n\n  if (!this._decodeHeader()) {\n    process.nextTick(cb);\n    return;\n  }\n\n  // We got the header, switch to block decoding mode. Also, call it directly\n  // in case we already have all the data (in which case `_write` wouldn't get\n  // called anymore).\n  this._write = this._writeChunk;\n  this._write(Buffer.alloc(0), encoding, cb);\n};\n\nBlockDecoder.prototype._writeChunk = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n\n  var block;\n  while ((block = tryReadBlock(tap))) {\n    if (!this._syncMarker.equals(block.sync)) {\n      cb(new Error('invalid sync marker'));\n      return;\n    }\n    this._decompress(block.data, this._createBlockCallback());\n  }\n\n  cb();\n};\n\nBlockDecoder.prototype._createBlockCallback = function () {\n  var self = this;\n  var index = this._index++;\n  this._pending++;\n\n  return function (err, data) {\n    if (err) {\n      self.emit('error', err);\n      return;\n    }\n    self._pending--;\n    self._queue.push(new BlockData(index, data));\n    if (self._needPush) {\n      self._needPush = false;\n      self._read();\n    }\n  };\n};\n\nBlockDecoder.prototype._read = function () {\n  var tap = this._blockTap;\n  if (tap.pos >= tap.buf.length) {\n    var data = this._queue.pop();\n    if (!data) {\n      if (this._finished && !this._pending) {\n        this.push(null);\n      } else {\n        this._needPush = true;\n      }\n      return; // Wait for more data.\n    }\n    tap.buf = data.buf;\n    tap.pos = 0;\n  }\n\n  this.push(this._readValue(tap)); // The read is guaranteed valid.\n};\n\n\n/**\n * Duplex stream for encoding.\n *\n */\nfunction RawEncoder(schema, opts) {\n  opts = opts || {};\n\n  stream.Transform.call(this, {\n    writableObjectMode: true,\n    allowHalfOpen: false\n  });\n\n  this._type = parse(schema);\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('error', err);\n    }\n  };\n  this._tap = new Tap(Buffer.alloc(opts.batchSize || 65536));\n}\nutil.inherits(RawEncoder, stream.Transform);\n\nRawEncoder.prototype._transform = function (val, encoding, cb) {\n  var tap = this._tap;\n  var buf = tap.buf;\n  var pos = tap.pos;\n\n  this._writeValue(tap, val);\n  if (!tap.isValid()) {\n    if (pos) {\n      // Emit any valid data.\n      this.push(copyBuffer(tap.buf, 0, pos));\n    }\n    var len = tap.pos - pos;\n    if (len > buf.length) {\n      // Not enough space for last written object, need to resize.\n      tap.buf = Buffer.alloc(2 * len);\n    }\n    tap.pos = 0;\n    this._writeValue(tap, val); // Rewrite last failed write.\n  }\n\n  cb();\n};\n\nRawEncoder.prototype._flush = function (cb) {\n  var tap = this._tap;\n  var pos = tap.pos;\n  if (pos) {\n    // This should only ever be false if nothing is written to the stream.\n    this.push(tap.buf.slice(0, pos));\n  }\n  cb();\n};\n\n\n/**\n * Duplex stream to write object container files.\n *\n * @param schema\n * @param opts {Object}\n *\n *  + `blockSize`, uncompressed.\n *  + `codec`\n *  + `codecs`\n *  + `noCheck`\n *  + `omitHeader`, useful to append to an existing block file.\n *\n */\nfunction BlockEncoder(schema, opts) {\n  opts = opts || {};\n\n  stream.Duplex.call(this, {\n    allowHalfOpen: true, // To support async compressors.\n    writableObjectMode: true\n  });\n\n  var obj, type;\n  if (schema instanceof schemas.types.Type) {\n    type = schema;\n    schema = undefined;\n  } else {\n    // Keep full schema to be able to write it to the header later.\n    obj = loadSchema(schema);\n    type = schemas.createType(obj);\n    schema = JSON.stringify(obj);\n  }\n\n  this._schema = schema;\n  this._type = type;\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('error', err);\n    }\n  };\n  this._blockSize = opts.blockSize || 65536;\n  this._tap = new Tap(Buffer.alloc(this._blockSize));\n  this._codecs = opts.codecs;\n  this._codec = opts.codec || 'null';\n  this._compress = null;\n  this._omitHeader = opts.omitHeader || false;\n  this._blockCount = 0;\n  this._syncMarker = opts.syncMarker || new utils.Lcg().nextBuffer(16);\n  this._queue = new utils.OrderedQueue();\n  this._pending = 0;\n  this._finished = false;\n  this._needPush = false;\n  this._downstream = null;\n\n  this.on('finish', function () {\n    this._finished = true;\n    if (this._blockCount) {\n      this._flushChunk();\n    }\n  });\n}\nutil.inherits(BlockEncoder, stream.Duplex);\n\nBlockEncoder.getDefaultCodecs = function () {\n  return {\n    'null': function (buf, cb) { cb(null, buf); },\n    'deflate': zlib.deflateRaw\n  };\n};\n\nBlockEncoder.prototype.getDownstream = function () {\n  return this._downstream;\n};\n\nBlockEncoder.prototype._write = function (val, encoding, cb) {\n  var codec = this._codec;\n  this._compress = (this._codecs || BlockEncoder.getDefaultCodecs())[codec];\n  if (!this._compress) {\n    this.emit('error', new Error(f('unsupported codec: %s', codec)));\n    return;\n  }\n\n  if (!this._omitHeader) {\n    var meta = {\n      'avro.schema': Buffer.from(this._schema || this._type.getSchema()),\n      'avro.codec': Buffer.from(this._codec)\n    };\n    var Header = HEADER_TYPE.getRecordConstructor();\n    var header = new Header(MAGIC_BYTES, meta, this._syncMarker);\n    this.push(header.$toBuffer());\n  }\n\n  this._write = this._writeChunk;\n  this._write(val, encoding, cb);\n};\n\nBlockEncoder.prototype._writeChunk = function (val, encoding, cb) {\n  var tap = this._tap;\n  var pos = tap.pos;\n\n  this._writeValue(tap, val);\n  if (!tap.isValid()) {\n    if (pos) {\n      this._flushChunk(pos);\n    }\n    var len = tap.pos - pos;\n    if (len > this._blockSize) {\n      // Not enough space for last written object, need to resize.\n      this._blockSize = len * 2;\n    }\n    tap.buf = Buffer.alloc(this._blockSize);\n    tap.pos = 0;\n    this._writeValue(tap, val); // Rewrite last failed write.\n  }\n  this._blockCount++;\n\n  cb();\n};\n\nBlockEncoder.prototype._flushChunk = function (pos) {\n  var tap = this._tap;\n  pos = pos || tap.pos;\n  this._compress(tap.buf.slice(0, pos), this._createBlockCallback());\n  this._blockCount = 0;\n};\n\nBlockEncoder.prototype._read = function () {\n  var self = this;\n  var data = this._queue.pop();\n  if (!data) {\n    if (this._finished && !this._pending) {\n      process.nextTick(function () { self.push(null); });\n    } else {\n      this._needPush = true;\n    }\n    return;\n  }\n\n  this.push(LONG_TYPE.toBuffer(data.count, true));\n  this.push(LONG_TYPE.toBuffer(data.buf.length, true));\n  this.push(data.buf);\n  this.push(this._syncMarker);\n};\n\nBlockEncoder.prototype._createBlockCallback = function () {\n  var self = this;\n  var index = this._index++;\n  var count = this._blockCount;\n  this._pending++;\n\n  return function (err, data) {\n    if (err) {\n      self.emit('error', err);\n      return;\n    }\n    self._pending--;\n    self._queue.push(new BlockData(index, data, count));\n    if (self._needPush) {\n      self._needPush = false;\n      self._read();\n    }\n  };\n};\n\n\n/**\n * Extract a container file's header synchronously.\n *\n */\nfunction extractFileHeader(path, opts) {\n  opts = opts || {};\n\n  var decode = opts.decode === undefined ? true : !!opts.decode;\n  var size = Math.max(opts.size || 4096, 4);\n  var fd = fs.openSync(path, 'r');\n  var buf = Buffer.alloc(size);\n  var pos = 0;\n  var tap = new Tap(buf);\n  var header = null;\n\n  while (pos < 4) {\n    // Make sure we have enough to check the magic bytes.\n    pos += fs.readSync(fd, buf, pos, size - pos);\n  }\n  if (MAGIC_BYTES.equals(buf.slice(0, 4))) {\n    do {\n      header = HEADER_TYPE._read(tap);\n    } while (!isValid());\n    if (decode !== false) {\n      var meta = header.meta;\n      meta['avro.schema'] = JSON.parse(meta['avro.schema'].toString());\n      if (meta['avro.codec'] !== undefined) {\n        meta['avro.codec'] = meta['avro.codec'].toString();\n      }\n    }\n  }\n  fs.closeSync(fd);\n  return header;\n\n  function isValid() {\n    if (tap.isValid()) {\n      return true;\n    }\n    var len = 2 * tap.buf.length;\n    var buf = Buffer.alloc(len);\n    len = fs.readSync(fd, buf, 0, len);\n    tap.buf = Buffer.concat([tap.buf, buf]);\n    tap.pos = 0;\n    return false;\n  }\n}\n\n\n/**\n * Readable stream of records from a local Avro file.\n *\n */\nfunction createFileDecoder(path, opts) {\n  return fs.createReadStream(path).pipe(new BlockDecoder(opts));\n}\n\n\n/**\n * Writable stream of records to a local Avro file.\n *\n */\nfunction createFileEncoder(path, schema, opts) {\n  var encoder = new BlockEncoder(schema, opts);\n  encoder._downstream = encoder.pipe(fs.createWriteStream(path, {defaultEncoding: 'binary'}));\n  return encoder;\n}\n\n\n// Helpers.\n\n/**\n * An indexed block.\n *\n * This can be used to preserve block order since compression and decompression\n * can cause some some blocks to be returned out of order. The count is only\n * used when encoding.\n *\n */\nfunction BlockData(index, buf, count) {\n  this.index = index;\n  this.buf = buf;\n  this.count = count | 0;\n}\n\n/**\n * Maybe get a block.\n *\n */\nfunction tryReadBlock(tap) {\n  var pos = tap.pos;\n  var block = BLOCK_TYPE._read(tap);\n  if (!tap.isValid()) {\n    tap.pos = pos;\n    return null;\n  }\n  return block;\n}\n\n/**\n * Create bytes consumer, either reading or skipping records.\n *\n */\nfunction createReader(decode, type) {\n  if (decode) {\n    return function (tap) { return type._read(tap); };\n  } else {\n    return (function (skipper) {\n      return function (tap) {\n        var pos = tap.pos;\n        skipper(tap);\n        return tap.buf.slice(pos, tap.pos);\n      };\n    })(type._skip);\n  }\n}\n\n/**\n * Copy a buffer.\n *\n * This avoids having to create a slice of the original buffer.\n *\n */\nfunction copyBuffer(buf, pos, len) {\n  var copy = Buffer.alloc(len);\n  buf.copy(copy, 0, pos, pos + len);\n  return copy;\n}\n\n/**\n * Try to load a schema.\n *\n * This method will attempt to load schemas from a file if the schema passed is\n * a string which isn't valid JSON and contains at least one slash.\n *\n */\nfunction loadSchema(schema) {\n  var obj;\n  if (typeof schema == 'string') {\n    try {\n      obj = JSON.parse(schema);\n    } catch (err) {\n      if (~schema.indexOf(path.sep)) {\n        // This can't be a valid name, so we interpret is as a filepath. This\n        // makes is always feasible to read a file, independent of its name\n        // (i.e. even if its name is valid JSON), by prefixing it with `./`.\n        obj = JSON.parse(fs.readFileSync(schema));\n      }\n    }\n  }\n  if (obj === undefined) {\n    obj = schema;\n  }\n  return obj;\n}\n\n\nmodule.exports = {\n  HEADER_TYPE: HEADER_TYPE, // For tests.\n  MAGIC_BYTES: MAGIC_BYTES, // Idem.\n  parse: parse,\n  createFileDecoder: createFileDecoder,\n  createFileEncoder: createFileEncoder,\n  extractFileHeader: extractFileHeader,\n  streams: {\n    RawDecoder: RawDecoder,\n    BlockDecoder: BlockDecoder,\n    RawEncoder: RawEncoder,\n    BlockEncoder: BlockEncoder\n  }\n};\n","/* jshint node: true */\n\n/**\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *  https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\n'use strict';\n\n/**\n * Main node.js entry point.\n *\n * See `etc/browser/avro.js` for the entry point used for browserify.\n *\n */\n\nvar files = require('./files'),\n    protocols = require('./protocols'),\n    schemas = require('./schemas'),\n    deprecated = require('../etc/deprecated/validator');\n\n\nmodule.exports = {\n  Type: schemas.Type,\n  Protocol: protocols.Protocol,\n  parse: files.parse,\n  createFileDecoder: files.createFileDecoder,\n  createFileEncoder: files.createFileEncoder,\n  extractFileHeader: files.extractFileHeader,\n  streams: files.streams,\n  types: schemas.types,\n  Validator: deprecated.Validator,\n  ProtocolValidator: deprecated.ProtocolValidator\n};\n","/* jshint node: true */\n\n/**\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *  https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\n'use strict';\n\n/**\n * This module implements Avro's IPC/RPC logic.\n *\n * This is done the Node.js way, mimicking the `EventEmitter` class.\n *\n */\n\nvar schemas = require('./schemas'),\n    utils = require('./utils'),\n    events = require('events'),\n    stream = require('stream'),\n    util = require('util');\n\n\nvar BOOLEAN_TYPE = schemas.createType('boolean');\nvar STRING_TYPE = schemas.createType('string');\nvar SYSTEM_ERROR_TYPE = schemas.createType(['string']);\n\nvar HANDSHAKE_REQUEST_TYPE = schemas.createType({\n  namespace: 'org.apache.avro.ipc',\n  name: 'HandshakeRequest',\n  type: 'record',\n  fields: [\n    {name: 'clientHash', type: {name: 'MD5', type: 'fixed', size: 16}},\n    {name: 'clientProtocol', type: ['null', 'string'], 'default': null},\n    {name: 'serverHash', type: 'org.apache.avro.ipc.MD5'},\n    {\n      name: 'meta',\n      type: ['null', {type: 'map', values: 'bytes'}],\n      'default': null\n    }\n  ]\n});\n\nvar HANDSHAKE_RESPONSE_TYPE = schemas.createType({\n  namespace: 'org.apache.avro.ipc',\n  name: 'HandshakeResponse',\n  type: 'record',\n  fields: [\n    {\n      name: 'match',\n      type: {\n        name: 'HandshakeMatch',\n        type: 'enum',\n        symbols: ['BOTH', 'CLIENT', 'NONE']\n      }\n    },\n    {name: 'serverProtocol', type: ['null', 'string'], 'default': null},\n    {\n      name: 'serverHash',\n      type: ['null', {name: 'MD5', type: 'fixed', size: 16}],\n      'default': null\n    },\n    {\n      name: 'meta',\n      type: ['null', {type: 'map', values: 'bytes'}],\n      'default': null\n    }\n  ]\n});\n\nvar HandshakeRequest = HANDSHAKE_REQUEST_TYPE.getRecordConstructor();\nvar HandshakeResponse = HANDSHAKE_RESPONSE_TYPE.getRecordConstructor();\nvar Tap = utils.Tap;\nvar f = util.format;\n\n\n/**\n * Protocol generation function.\n *\n * This should be used instead of the protocol constructor. The protocol's\n * constructor performs no logic to better support efficient protocol copy.\n *\n */\nfunction createProtocol(attrs, opts) {\n  opts = opts || {};\n\n  var name = attrs.protocol;\n  if (!name) {\n    throw new Error('missing protocol name');\n  }\n  opts.namespace = attrs.namespace;\n  if (opts.namespace && !~name.indexOf('.')) {\n    name = f('%s.%s', opts.namespace, name);\n  }\n\n  if (attrs.types) {\n    attrs.types.forEach(function (obj) { schemas.createType(obj, opts); });\n  }\n  var messages = {};\n  if (attrs.messages) {\n    Object.keys(attrs.messages).forEach(function (key) {\n      messages[key] = new Message(key, attrs.messages[key], opts);\n    });\n  }\n\n  return new Protocol(name, messages, opts.registry || {});\n}\n\n/**\n * An Avro protocol.\n *\n * It contains a cache for all remote protocols encountered by its emitters and\n * listeners. Note that a protocol can be listening to multiple listeners at a\n * given time. This can be a mix of stateful or stateless listeners.\n *\n */\nfunction Protocol(name, messages, types, ptcl) {\n  this._name = name;\n  this._messages = messages;\n  this._types = types;\n  this._parent = ptcl;\n\n  // Cache a string instead of the buffer to avoid retaining an entire slab.\n  this._hashString = utils.getHash(this.toString()).toString('binary');\n\n  // Listener callbacks. Note the prototype used for handlers when this is a\n  // subprotocol. This lets us easily implement the desired fallback behavior.\n  var self = this;\n  this._handlers = Object.create(ptcl ? ptcl._handlers : null);\n  this._onListenerCall = function (name, req, cb) {\n    var handler = self._handlers[name];\n    if (!handler) {\n      cb(new Error(f('unsupported message: %s', name)));\n    } else {\n      handler.call(self, req, this, cb);\n    }\n  };\n\n  // Resolvers are split since we want emitters to still be able to talk to\n  // servers with more messages (which would be incompatible the other way).\n  this._emitterResolvers = ptcl ? ptcl._emitterResolvers : {};\n  this._listenerResolvers = ptcl ? ptcl._listenerResolvers : {};\n}\n\nProtocol.prototype.subprotocol = function () {\n  return new Protocol(this._name, this._messages, this._types, this);\n};\n\nProtocol.prototype.emit = function (name, req, emitter, cb) {\n  cb = cb || throwError; // To provide a more helpful error message.\n\n  if (\n    !(emitter instanceof MessageEmitter) ||\n    emitter._ptcl._hashString !== this._hashString\n  ) {\n    asyncAvroCb(this, cb, 'invalid emitter');\n    return;\n  }\n\n  var message = this._messages[name];\n  if (!message) {\n    asyncAvroCb(this, cb, f('unknown message: %s', name));\n    return;\n  }\n\n  emitter._emit(message, req, cb);\n};\n\nProtocol.prototype.createEmitter = function (transport, opts, cb) {\n  if (!cb && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n\n  var emitter;\n  if (typeof transport == 'function') {\n    emitter = new StatelessEmitter(this, transport, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    emitter = new StatefulEmitter(this, readable, writable, opts);\n  }\n  if (cb) {\n    emitter.once('eot', cb);\n  }\n  return emitter;\n};\n\nProtocol.prototype.on = function (name, handler) {\n  if (!this._messages[name]) {\n    throw new Error(f('unknown message: %s', name));\n  }\n  this._handlers[name] = handler;\n  return this;\n};\n\nProtocol.prototype.createListener = function (transport, opts, cb) {\n  if (!cb && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n\n  var listener;\n  if (typeof transport == 'function') {\n    listener = new StatelessListener(this, transport, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    listener = new StatefulListener(this, readable, writable, opts);\n  }\n  if (cb) {\n    listener.once('eot', cb);\n  }\n  return listener.on('_call', this._onListenerCall);\n};\n\nProtocol.prototype.getType = function (name) { return this._types[name]; };\n\nProtocol.prototype.getName = function () { return this._name; };\n\nProtocol.prototype.getMessages = function () { return this._messages; };\n\nProtocol.prototype.toString = function () {\n  var namedTypes = [];\n  Object.keys(this._types).forEach(function (name) {\n    var type = this._types[name];\n    if (type.getName()) {\n      namedTypes.push(type);\n    }\n  }, this);\n\n  return schemas.stringify({\n    protocol: this._name,\n    types: namedTypes.length ? namedTypes : undefined,\n    messages: this._messages\n  });\n};\n\nProtocol.prototype.inspect = function () {\n  return f('<Protocol %j>', this._name);\n};\n\n/**\n * Base message emitter class.\n *\n * See below for the two available variants.\n *\n */\nfunction MessageEmitter(ptcl, opts) {\n  events.EventEmitter.call(this);\n\n  this._ptcl = ptcl;\n  this._resolvers = ptcl._emitterResolvers;\n  this._serverHashString = ptcl._hashString;\n  this._idType = IdType.createMetadataType(opts.IdType);\n  this._bufferSize = opts.bufferSize || 2048;\n  this._frameSize = opts.frameSize || 2048;\n\n  this.once('_eot', function (pending) { this.emit('eot', pending); });\n}\nutil.inherits(MessageEmitter, events.EventEmitter);\n\nMessageEmitter.prototype._generateResolvers = function (\n  hashString, serverPtcl\n) {\n  var resolvers = {};\n  var emitterMessages = this._ptcl._messages;\n  var serverMessages = serverPtcl._messages;\n  Object.keys(emitterMessages).forEach(function (name) {\n    var cm = emitterMessages[name];\n    var sm = serverMessages[name];\n    if (!sm) {\n      throw new Error(f('missing server message: %s', name));\n    }\n    resolvers[name] = {\n      responseType: cm.responseType.createResolver(sm.responseType),\n      errorType: cm.errorType.createResolver(sm.errorType)\n    };\n  });\n  this._resolvers[hashString] = resolvers;\n};\n\nMessageEmitter.prototype._createHandshakeRequest = function (\n  hashString, noPtcl\n) {\n  return new HandshakeRequest(\n    getHash(this._ptcl),\n    noPtcl ? null : {string: this._ptcl.toString()},\n    Buffer.from(hashString, 'binary')\n  );\n};\n\nMessageEmitter.prototype._finalizeHandshake = function (tap, handshakeReq) {\n  var res = HANDSHAKE_RESPONSE_TYPE._read(tap);\n  this.emit('handshake', handshakeReq, res);\n\n  if (handshakeReq.clientProtocol && res.match === 'NONE') {\n    // If the emitter's protocol was included in the original request, this is\n    // not a failure which a retry will fix.\n    var buf = res.meta && res.meta.map.error;\n    throw new Error(buf ? buf.toString() : 'handshake error');\n  }\n\n  var hashString;\n  if (res.serverHash && res.serverProtocol) {\n    // This means the request didn't include the correct server hash. Note that\n    // we use the handshake response's hash rather than our computed one in\n    // case the server computes it differently.\n    hashString = res.serverHash['org.apache.avro.ipc.MD5'].toString('binary');\n    if (!canResolve(this, hashString)) {\n      this._generateResolvers(\n        hashString,\n        createProtocol(JSON.parse(res.serverProtocol.string))\n      );\n    }\n    // Make this hash the new default.\n    this._serverHashString = hashString;\n  } else {\n    hashString = handshakeReq.serverHash.toString('binary');\n  }\n\n  // We return the server's hash for stateless emitters. It might be that the\n  // default hash changes in between requests, in which case using the default\n  // one will fail.\n  return {match: res.match, serverHashString: hashString};\n};\n\nMessageEmitter.prototype._encodeRequest = function (tap, message, req) {\n  safeWrite(tap, STRING_TYPE, message.name);\n  safeWrite(tap, message.requestType, req);\n};\n\nMessageEmitter.prototype._decodeArguments = function (\n  tap, hashString, message\n) {\n  var resolvers = getResolvers(this, hashString, message);\n  var args = [null, null];\n  if (tap.readBoolean()) {\n    args[0] = resolvers.errorType._read(tap);\n  } else {\n    args[1] = resolvers.responseType._read(tap);\n  }\n  if (!tap.isValid()) {\n    throw new Error('truncated message');\n  }\n  return args;\n};\n\n/**\n * Factory-based emitter.\n *\n * This emitter doesn't keep a persistent connection to the server and requires\n * prepending a handshake to each message emitted. Usage examples include\n * talking to an HTTP server (where the factory returns an HTTP request).\n *\n * Since each message will use its own writable/readable stream pair, the\n * advantage of this emitter is that it is able to keep track of which response\n * corresponds to each request without relying on messages' metadata. In\n * particular, this means these emitters are compatible with any server\n * implementation.\n *\n */\nfunction StatelessEmitter(ptcl, writableFactory, opts) {\n  opts = opts || {};\n  MessageEmitter.call(this, ptcl, opts);\n\n  this._writableFactory = writableFactory;\n  this._id = 1;\n  this._pending = {};\n  this._destroyed = false;\n  this._interrupted = false;\n}\nutil.inherits(StatelessEmitter, MessageEmitter);\n\nStatelessEmitter.prototype._emit = function (message, req, cb) {\n  // We enclose the server's hash inside this message's closure since the\n  // emitter might be emitting several message concurrently and the hash might\n  // change before the response returns (unlikely but possible if the emitter\n  // talks to multiple servers at once or the server changes protocol).\n  var serverHashString = this._serverHashString;\n  var id = this._id++;\n  var self = this;\n\n  this._pending[id] = cb;\n  if (this._destroyed) {\n    asyncAvroCb(undefined, done, 'emitter destroyed');\n    return;\n  }\n  emit(false);\n\n  function emit(retry) {\n    var tap = new Tap(Buffer.alloc(self._bufferSize));\n\n    var handshakeReq = self._createHandshakeRequest(serverHashString, !retry);\n    safeWrite(tap, HANDSHAKE_REQUEST_TYPE, handshakeReq);\n    try {\n      safeWrite(tap, self._idType, id);\n      self._encodeRequest(tap, message, req);\n    } catch (err) {\n      asyncAvroCb(undefined, done, err);\n      return;\n    }\n\n    var writable = self._writableFactory(function onReadable(readable) {\n      if (self._interrupted) {\n        // In case this function is called asynchronously (e.g. when sending\n        // HTTP requests), it might be that we have ended since.\n        return;\n      }\n\n      readable\n        .pipe(new MessageDecoder(true))\n        .on('error', done)\n        // This will happen when the readable stream ends before a single\n        // message has been decoded (e.g. on invalid response).\n        .on('data', function (buf) {\n          readable.unpipe(this); // Single message per readable stream.\n          if (self._interrupted) {\n            return;\n          }\n\n          var tap = new Tap(buf);\n          var args;\n          try {\n            var info = self._finalizeHandshake(tap, handshakeReq);\n            serverHashString = info.serverHashString;\n            if (info.match === 'NONE') {\n              emit(true); // Retry, attaching emitter protocol this time.\n              return;\n            }\n            self._idType._read(tap); // Skip metadata.\n            args = self._decodeArguments(tap, serverHashString, message);\n          } catch (err) {\n            done(err);\n            return;\n          }\n          done.apply(undefined, args);\n        });\n    });\n\n    var encoder = new MessageEncoder(self._frameSize);\n    encoder.pipe(writable);\n    encoder.end(tap.getValue());\n  }\n\n  function done(err, res) {\n    var cb = self._pending[id];\n    delete self._pending[id];\n    cb.call(self._ptcl, err, res);\n    if (self._destroyed) {\n      self.destroy();\n    }\n  }\n};\n\nStatelessEmitter.prototype.destroy = function (noWait) {\n  this._destroyed = true;\n\n  var pendingIds = Object.keys(this._pending);\n  if (noWait) {\n    this._interrupted = true;\n    pendingIds.forEach(function (id) {\n      this._pending[id]({string: 'interrupted'});\n      delete this._pending[id];\n    }, this);\n  }\n\n  if (noWait || !pendingIds.length) {\n    this.emit('_eot', pendingIds.length);\n  }\n};\n\n/**\n * Multiplexing emitter.\n *\n * These emitters reuse the same streams (both readable and writable) for all\n * messages. This avoids a lot of overhead (e.g. creating new connections,\n * re-issuing handshakes) but requires the server to include compatible\n * metadata in each response (namely forwarding each request's ID into its\n * response).\n *\n * A custom metadata format can be specified via the `idType` option. The\n * default is compatible with this package's default server (i.e. listener)\n * implementation.\n *\n */\nfunction StatefulEmitter(ptcl, readable, writable, opts) {\n  opts = opts || {};\n  MessageEmitter.call(this, ptcl, opts);\n\n  this._readable = readable;\n  this._writable = writable;\n  this._id = 1;\n  this._pending = {};\n  this._started = false;\n  this._destroyed = false;\n  this._ended = false; // Readable input ended.\n  this._decoder = new MessageDecoder();\n  this._encoder = new MessageEncoder(this._frameSize);\n\n  var handshakeReq = null;\n  var self = this;\n\n  process.nextTick(function () {\n    self._readable.pipe(self._decoder)\n      .on('error', function (err) { self.emit('error', err); })\n      .on('data', onHandshakeData)\n      .on('end', function () {\n        self._ended = true;\n        self.destroy();\n      });\n\n    self._encoder.pipe(self._writable);\n    emitHandshake(true);\n  });\n\n  function emitHandshake(noPtcl) {\n    handshakeReq = self._createHandshakeRequest(\n      self._serverHashString,\n      noPtcl\n    );\n    self._encoder.write(handshakeReq.$toBuffer());\n  }\n\n  function onHandshakeData(buf) {\n    var tap = new Tap(buf);\n    var info;\n    try {\n      info = self._finalizeHandshake(tap, handshakeReq);\n    } catch (err) {\n      self.emit('error', err);\n      self.destroy(); // This isn't a recoverable error.\n      return;\n    }\n\n    if (info.match !== 'NONE') {\n      self._decoder\n        .removeListener('data', onHandshakeData)\n        .on('data', onMessageData);\n      self._started = true;\n      self.emit('_start'); // Send any pending messages.\n    } else {\n      emitHandshake(false);\n    }\n  }\n\n  function onMessageData(buf) {\n    var tap = new Tap(buf);\n    var id;\n    try {\n      id = self._idType._read(tap);\n      if (!id) {\n        throw new Error('missing ID');\n      }\n    } catch (err) {\n      self.emit('error', new Error('invalid metadata: ' + err.message));\n      return;\n    }\n\n    var info = self._pending[id];\n    if (info === undefined) {\n      self.emit('error', new Error('orphan response: ' + id));\n      return;\n    }\n\n    var args;\n    try {\n      args = self._decodeArguments(\n        tap,\n        self._serverHashString,\n        info.message\n      );\n    } catch (err) {\n      info.cb({string: 'invalid response: ' + err.message});\n      return;\n    }\n    delete self._pending[id];\n    info.cb.apply(self._ptcl, args);\n    if (self._destroyed) {\n      self.destroy();\n    }\n  }\n}\nutil.inherits(StatefulEmitter, MessageEmitter);\n\nStatefulEmitter.prototype._emit = function (message, req, cb) {\n  if (this._destroyed) {\n    asyncAvroCb(this._ptcl, cb, 'emitter destroyed');\n    return;\n  }\n\n  var self = this;\n  if (!this._started) {\n    this.once('_start', function () { self._emit(message, req, cb); });\n    return;\n  }\n\n  var tap = new Tap(Buffer.alloc(this._bufferSize));\n  var id = this._id++;\n  try {\n    safeWrite(tap, this._idType, -id);\n    this._encodeRequest(tap, message, req);\n  } catch (err) {\n    asyncAvroCb(this._ptcl, cb, err);\n    return;\n  }\n\n  if (!message.oneWay) {\n    this._pending[id] = {message: message, cb: cb};\n  }\n  this._encoder.write(tap.getValue());\n};\n\nStatefulEmitter.prototype.destroy = function (noWait) {\n  this._destroyed = true;\n  if (!this._started) {\n    this.emit('_start'); // Error out any pending calls.\n  }\n\n  var pendingIds = Object.keys(this._pending);\n  if (pendingIds.length && !(noWait || this._ended)) {\n    return; // Wait for pending requests.\n  }\n  pendingIds.forEach(function (id) {\n    var cb = this._pending[id].cb;\n    delete this._pending[id];\n    cb({string: 'interrupted'});\n  }, this);\n\n  this._readable.unpipe(this._decoder);\n  this._encoder.unpipe(this._writable);\n  this.emit('_eot', pendingIds.length);\n};\n\n/**\n * The server-side emitter equivalent.\n *\n * In particular it is responsible for handling handshakes appropriately.\n *\n */\nfunction MessageListener(ptcl, opts) {\n  events.EventEmitter.call(this);\n  opts = opts || {};\n\n  this._ptcl = ptcl;\n  this._resolvers = ptcl._listenerResolvers;\n  this._emitterHashString = null;\n  this._idType = IdType.createMetadataType(opts.IdType);\n  this._bufferSize = opts.bufferSize || 2048;\n  this._frameSize = opts.frameSize || 2048;\n  this._decoder = new MessageDecoder();\n  this._encoder = new MessageEncoder(this._frameSize);\n  this._destroyed = false;\n  this._pending = 0;\n\n  this.once('_eot', function (pending) { this.emit('eot', pending); });\n}\nutil.inherits(MessageListener, events.EventEmitter);\n\nMessageListener.prototype._generateResolvers = function (\n  hashString, emitterPtcl\n) {\n  var resolvers = {};\n  var clientMessages = emitterPtcl._messages;\n  var serverMessages = this._ptcl._messages;\n  Object.keys(clientMessages).forEach(function (name) {\n    var sm = serverMessages[name];\n    if (!sm) {\n      throw new Error(f('missing server message: %s', name));\n    }\n    var cm = clientMessages[name];\n    resolvers[name] = {\n      requestType: sm.requestType.createResolver(cm.requestType)\n    };\n  });\n  this._resolvers[hashString] = resolvers;\n};\n\nMessageListener.prototype._validateHandshake = function (reqTap, resTap) {\n  // Reads handshake request and write corresponding response out. If an error\n  // occurs when parsing the request, a response with match NONE will be sent.\n  // Also emits 'handshake' event with both the request and the response.\n  var validationErr = null;\n  var handshakeReq;\n  var serverHashString;\n  try {\n    handshakeReq = HANDSHAKE_REQUEST_TYPE._read(reqTap);\n    serverHashString = handshakeReq.serverHash.toString('binary');\n  } catch (err) {\n    validationErr = err;\n  }\n\n  if (!validationErr) {\n    this._emitterHashString = handshakeReq.clientHash.toString('binary');\n    if (!canResolve(this, this._emitterHashString)) {\n      var emitterPtclString = handshakeReq.clientProtocol;\n      if (emitterPtclString) {\n        try {\n          this._generateResolvers(\n            this._emitterHashString,\n            createProtocol(JSON.parse(emitterPtclString.string))\n          );\n        } catch (err) {\n          validationErr = err;\n        }\n      } else {\n        validationErr = new Error('unknown client protocol hash');\n      }\n    }\n  }\n\n  // We use the handshake response's meta field to transmit an eventual error\n  // to the client. This will let us display a more useful message later on.\n  var serverMatch = serverHashString === this._ptcl._hashString;\n  var handshakeRes = new HandshakeResponse(\n    validationErr ? 'NONE' : serverMatch ? 'BOTH' : 'CLIENT',\n    serverMatch ? null : {string: this._ptcl.toString()},\n    serverMatch ? null : {'org.apache.avro.ipc.MD5': getHash(this._ptcl)},\n    validationErr ? {map: {error: Buffer.from(validationErr.message)}} : null\n  );\n\n  this.emit('handshake', handshakeReq, handshakeRes);\n  safeWrite(resTap, HANDSHAKE_RESPONSE_TYPE, handshakeRes);\n  return validationErr === null;\n};\n\nMessageListener.prototype._decodeRequest = function (tap, message) {\n  var resolvers = getResolvers(this, this._emitterHashString, message);\n  var val = resolvers.requestType._read(tap);\n  if (!tap.isValid()) {\n    throw new Error('invalid request');\n  }\n  return val;\n};\n\nMessageListener.prototype._encodeSystemError = function (tap, err) {\n  safeWrite(tap, BOOLEAN_TYPE, true);\n  safeWrite(tap, SYSTEM_ERROR_TYPE, avroError(err));\n};\n\nMessageListener.prototype._encodeArguments = function (\n  tap, message, err, res\n) {\n  var noError = err === null;\n  var pos = tap.pos;\n  safeWrite(tap, BOOLEAN_TYPE, !noError);\n  try {\n    if (noError) {\n      safeWrite(tap, message.responseType, res);\n    } else {\n      if (err instanceof Error) {\n        // Convenience to allow emitter to use JS errors inside handlers.\n        err = avroError(err);\n      }\n      safeWrite(tap, message.errorType, err);\n    }\n  } catch (err) {\n    tap.pos = pos;\n    this._encodeSystemError(tap, err);\n  }\n};\n\nMessageListener.prototype.destroy = function (noWait) {\n  if (!this._destroyed) {\n    // Stop listening. This will also correctly push back any unused bytes into\n    // the readable stream (via `MessageDecoder`'s `unpipe` handler).\n    this._readable.unpipe(this._decoder);\n  }\n\n  this._destroyed = true;\n  if (noWait || !this._pending) {\n    this._encoder.unpipe(this._writable);\n    this.emit('_eot', this._pending);\n  }\n};\n\n/**\n * Listener for stateless transport.\n *\n * This listener expect a handshake to precede each message.\n *\n */\nfunction StatelessListener(ptcl, readableFactory, opts) {\n  MessageListener.call(this, ptcl, opts);\n\n  this._tap = new Tap(Buffer.alloc(this._bufferSize));\n  this._message = undefined;\n\n  var self = this;\n  this._readable = readableFactory(function (writable) {\n    // The encoder will buffer writes that happen before this function is\n    // called, so we don't need to do any special handling.\n    self._writable = self._encoder\n      .pipe(writable)\n      .on('finish', onEnd);\n  });\n\n  this._readable.pipe(this._decoder)\n    .on('data', onRequestData)\n    .on('end', onEnd);\n\n  function onRequestData(buf) {\n    self._pending++;\n    self.destroy(); // Only one message per stateless listener.\n\n    var reqTap = new Tap(buf);\n    if (!self._validateHandshake(reqTap, self._tap)) {\n      onResponse(new Error('invalid handshake'));\n      return;\n    }\n\n    var name;\n    var req;\n    try {\n      self._idType._read(reqTap); // Skip metadata.\n      name = STRING_TYPE._read(reqTap);\n      self._message = self._ptcl._messages[name];\n      if (!self._message) {\n        throw new Error(f('unknown message: %s', name));\n      }\n      req = self._decodeRequest(reqTap, self._message);\n    } catch (err) {\n      onResponse(err);\n      return;\n    }\n\n    self.emit('_call', name, req, onResponse);\n  }\n\n  function onResponse(err, res) {\n    safeWrite(self._tap, self._idType, 0);\n    if (!self._message) {\n      self._encodeSystemError(self._tap, err);\n    } else {\n      self._encodeArguments(self._tap, self._message, err, res);\n    }\n    self._pending--;\n    self._encoder.end(self._tap.getValue());\n  }\n\n  function onEnd() { self.destroy(); }\n}\nutil.inherits(StatelessListener, MessageListener);\n\n/**\n * Stateful transport listener.\n *\n * A handshake is done when the listener is first opened, then all messages are\n * sent without.\n *\n */\nfunction StatefulListener(ptcl, readable, writable, opts) {\n  MessageListener.call(this, ptcl, opts);\n\n  this._readable = readable;\n  this._writable = writable;\n\n  var self = this;\n\n  this._readable\n    .pipe(this._decoder)\n    .on('data', onHandshakeData)\n    .on('end', function () { self.destroy(); });\n\n  this._encoder\n    .pipe(this._writable)\n    .on('finish', function () { self.destroy(); });\n\n  function onHandshakeData(buf) {\n    var reqTap = new Tap(buf);\n    var resTap = new Tap(Buffer.alloc(self._bufferSize));\n    if (self._validateHandshake(reqTap, resTap)) {\n      self._decoder\n        .removeListener('data', onHandshakeData)\n        .on('data', onRequestData);\n    }\n    self._encoder.write(resTap.getValue());\n  }\n\n  function onRequestData(buf) {\n    var reqTap = new Tap(buf);\n    var resTap = new Tap(Buffer.alloc(self._bufferSize));\n    var id = 0;\n    try {\n      id = -self._idType._read(reqTap) | 0;\n      if (!id) {\n        throw new Error('missing ID');\n      }\n    } catch (err) {\n      self.emit('error', new Error('invalid metadata: ' + err.message));\n      return;\n    }\n\n    self._pending++;\n    var name;\n    var message;\n    var req;\n    try {\n      name = STRING_TYPE._read(reqTap);\n      message = self._ptcl._messages[name];\n      if (!message) {\n        throw new Error('unknown message: ' + name);\n      }\n      req = self._decodeRequest(reqTap, message);\n    } catch (err) {\n      onResponse(err);\n      return;\n    }\n\n    if (message.oneWay) {\n      self.emit('_call', name, req);\n      self._pending--;\n    } else {\n      self.emit('_call', name, req, onResponse);\n    }\n\n    function onResponse(err, res) {\n      self._pending--;\n      safeWrite(resTap, self._idType, id);\n      if (!message) {\n        self._encodeSystemError(resTap, err);\n      } else {\n        self._encodeArguments(resTap, message, err, res);\n      }\n      self._encoder.write(resTap.getValue(), undefined, function () {\n        if (!self._pending && self._destroyed) {\n          self.destroy(); // For real this time.\n        }\n      });\n    }\n  }\n}\nutil.inherits(StatefulListener, MessageListener);\n\n// Helpers.\n\n/**\n * An Avro message.\n *\n */\nfunction Message(name, attrs, opts) {\n  this.name = name;\n\n  this.requestType = schemas.createType({\n    name: name,\n    type: 'request',\n    fields: attrs.request\n  }, opts);\n\n  if (!attrs.response) {\n    throw new Error('missing response');\n  }\n  this.responseType = schemas.createType(attrs.response, opts);\n\n  var errors = attrs.errors || [];\n  errors.unshift('string');\n  this.errorType = schemas.createType(errors, opts);\n\n  this.oneWay = !!attrs['one-way'];\n  if (this.oneWay) {\n    if (\n      !(this.responseType instanceof schemas.types.NullType) ||\n      errors.length > 1\n    ) {\n      throw new Error('unapplicable one-way parameter');\n    }\n  }\n}\n\nMessage.prototype.toJSON = function () {\n  var obj = {\n    request: this.requestType.getFields(),\n    response: this.responseType\n  };\n  var errorTypes = this.errorType.getTypes();\n  if (errorTypes.length > 1) {\n    obj.errors = schemas.createType(errorTypes.slice(1));\n  }\n  return obj;\n};\n\n/**\n * \"Framing\" stream.\n *\n * @param frameSize {Number} (Maximum) size in bytes of each frame. The last\n * frame might be shorter.\n *\n */\nfunction MessageEncoder(frameSize) {\n  stream.Transform.call(this);\n  this._frameSize = frameSize | 0;\n  if (this._frameSize <= 0) {\n    throw new Error('invalid frame size');\n  }\n}\nutil.inherits(MessageEncoder, stream.Transform);\n\nMessageEncoder.prototype._transform = function (buf, encoding, cb) {\n  var frames = [];\n  var length = buf.length;\n  var start = 0;\n  var end;\n  do {\n    end = start + this._frameSize;\n    if (end > length) {\n      end = length;\n    }\n    frames.push(intBuffer(end - start));\n    frames.push(buf.slice(start, end));\n  } while ((start = end) < length);\n  frames.push(intBuffer(0));\n  cb(null, Buffer.concat(frames));\n};\n\n/**\n * \"Un-framing\" stream.\n *\n * @param noEmpty {Boolean} Emit an error if the decoder ends before emitting a\n * single frame.\n *\n * This stream should only be used by being piped/unpiped to. Otherwise there\n * is a risk that too many bytes get consumed from the source stream (i.e.\n * data corresponding to a partial message might be lost).\n *\n */\nfunction MessageDecoder(noEmpty) {\n  stream.Transform.call(this);\n  this._buf = Buffer.alloc(0);\n  this._bufs = [];\n  this._length = 0;\n  this._empty = !!noEmpty;\n\n  this\n    .on('finish', function () { this.push(null); })\n    .on('unpipe', function (src) {\n      if (~this._length && !src._readableState.ended) {\n        // Not ideal to rely on this to check whether we can unshift, but the\n        // official documentation mentions it (in the context of the read\n        // buffers) so it should be stable. Alternatives are more complex,\n        // costly (e.g. attaching a handler on pipe), and not as fool-proof\n        // (the stream might have ended earlier).\n        this._bufs.push(this._buf);\n        src.unshift(Buffer.concat(this._bufs));\n      }\n    });\n}\nutil.inherits(MessageDecoder, stream.Transform);\n\nMessageDecoder.prototype._transform = function (buf, encoding, cb) {\n  buf = Buffer.concat([this._buf, buf]);\n  var frameLength;\n  while (\n    buf.length >= 4 &&\n    buf.length >= (frameLength = buf.readInt32BE(0)) + 4\n  ) {\n    if (frameLength) {\n      this._bufs.push(buf.slice(4, frameLength + 4));\n      this._length += frameLength;\n    } else {\n      var frame = Buffer.concat(this._bufs, this._length);\n      this._empty = false;\n      this._length = 0;\n      this._bufs = [];\n      this.push(frame);\n    }\n    buf = buf.slice(frameLength + 4);\n  }\n  this._buf = buf;\n  cb();\n};\n\nMessageDecoder.prototype._flush = function () {\n  if (this._length || this._buf.length) {\n    this._length = -1; // Don't unshift data on incoming unpipe.\n    this.emit('error', new Error('trailing data'));\n  } else if (this._empty) {\n    this.emit('error', new Error('no message decoded'));\n  } else {\n    this.emit('finish');\n  }\n};\n\n/**\n * Default ID generator, using Avro messages' metadata field.\n *\n * This is required for stateful emitters to work and can be overridden to read\n * or write arbitrary metadata. Note that the message contents are\n * (intentionally) not available when updating this metadata.\n *\n */\nfunction IdType(attrs, opts) {\n  schemas.types.LogicalType.call(this, attrs, opts);\n}\nutil.inherits(IdType, schemas.types.LogicalType);\n\nIdType.prototype._fromValue = function (val) {\n  var buf = val.id;\n  return buf && buf.length === 4 ? buf.readInt32BE(0) : 0;\n};\n\nIdType.prototype._toValue = function (any) {\n  return {id: intBuffer(any | 0)};\n};\n\nIdType.createMetadataType = function (Type) {\n  Type = Type || IdType;\n  return new Type({type: 'map', values: 'bytes'});\n};\n\n/**\n * Returns a buffer containing an integer's big-endian representation.\n *\n * @param n {Number} Integer.\n *\n */\nfunction intBuffer(n) {\n  var buf = Buffer.alloc(4);\n  buf.writeInt32BE(n);\n  return buf;\n}\n\n/**\n * Write and maybe resize.\n *\n * @param tap {Tap} Tap written to.\n * @param type {Type} Avro type.\n * @param val {...} Corresponding Avro value.\n *\n */\nfunction safeWrite(tap, type, val) {\n  var pos = tap.pos;\n  type._write(tap, val);\n\n  if (!tap.isValid()) {\n    var buf = Buffer.alloc(tap.pos);\n    tap.buf.copy(buf, 0, 0, pos);\n    tap.buf = buf;\n    tap.pos = pos;\n    type._write(tap, val);\n  }\n}\n\n/**\n * Default callback when not provided.\n *\n */\nfunction throwError(err) {\n  if (!err) {\n    return;\n  }\n  if (typeof err == 'object' && err.string) {\n    err = err.string;\n  }\n  if (typeof err == 'string') {\n    err = new Error(err);\n  }\n  throw err;\n}\n\n/**\n * Convert an error message into a format suitable for RPC.\n *\n * @param err {Error|String} Error message. It will be converted into valid\n * format for Avro.\n *\n */\nfunction avroError(err) {\n  if (err instanceof Error) {\n    err = err.message;\n  }\n  return {string: err};\n}\n\n/**\n * Asynchronous error handling.\n *\n * @param cb {Function} Callback.\n * @param err {...} Error, passed as first argument to `cb.` If an `Error`\n * instance or a string, it will be converted into valid format for Avro.\n * @param res {...} Response. Passed as second argument to `cb`.\n *\n */\nfunction asyncAvroCb(ctx, cb, err, res) {\n  process.nextTick(function () { cb.call(ctx, avroError(err), res); });\n}\n\n/**\n * Convenience function to get a protocol's hash.\n *\n * @param ptcl {Protocol} Any protocol.\n *\n */\nfunction getHash(ptcl) {\n  return Buffer.from(ptcl._hashString, 'binary');\n}\n\n/**\n * Whether a emitter or listener can resolve messages from a hash string.\n *\n * @param emitter {MessageEmitter|MessageListener}\n * @param hashString {String}\n *\n */\nfunction canResolve(emitter, hashString) {\n  var resolvers = emitter._resolvers[hashString];\n  return !!resolvers || hashString === emitter._ptcl._hashString;\n}\n\n/**\n * Retrieve resolvers for a given hash string.\n *\n * @param emitter {MessageEmitter|MessageListener}\n * @param hashString {String}\n * @param message {Message}\n *\n */\nfunction getResolvers(emitter, hashString, message) {\n  if (hashString === emitter._ptcl._hashString) {\n    return message;\n  }\n  var resolvers = emitter._resolvers[hashString];\n  return resolvers && resolvers[message.name];\n}\n\n/**\n * Check whether something is a stream.\n *\n * @param any {Object} Any object.\n *\n */\nfunction isStream(any) {\n  // This is a hacky way of checking that the transport is a stream-like\n  // object. We unfortunately can't use `instanceof Stream` checks since\n  // some libraries (e.g. websocket-stream) return streams which don't\n  // inherit from it.\n  return !!any.pipe;\n}\n\n\nmodule.exports = {\n  HANDSHAKE_REQUEST_TYPE: HANDSHAKE_REQUEST_TYPE,\n  HANDSHAKE_RESPONSE_TYPE: HANDSHAKE_RESPONSE_TYPE,\n  IdType: IdType,\n  Message: Message,\n  Protocol: Protocol,\n  createProtocol: createProtocol,\n  emitters: {\n    StatefulEmitter: StatefulEmitter,\n    StatelessEmitter: StatelessEmitter\n  },\n  listeners: {\n    StatefulListener: StatefulListener,\n    StatelessListener: StatelessListener\n  },\n  streams: {\n    MessageDecoder: MessageDecoder,\n    MessageEncoder: MessageEncoder\n  },\n  throwError: throwError\n};\n","/* jshint node: true */\n\n/**\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *  https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\n'use strict';\n\nvar utils = require('./utils'),\n    buffer = require('buffer'), // For `SlowBuffer`.\n    util = require('util');\n\n// Convenience imports.\nvar Tap = utils.Tap;\nvar f = util.format;\nvar Buffer = buffer.Buffer;\n\n// All Avro types.\nvar TYPES = {\n  'array': ArrayType,\n  'boolean': BooleanType,\n  'bytes': BytesType,\n  'double': DoubleType,\n  'enum': EnumType,\n  'error': RecordType,\n  'fixed': FixedType,\n  'float': FloatType,\n  'int': IntType,\n  'long': LongType,\n  'map': MapType,\n  'null': NullType,\n  'record': RecordType,\n  'request': RecordType,\n  'string': StringType,\n  'union': UnionType\n};\n\n// Valid (field, type, and symbol) name regex.\nvar NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;\n\n// Random generator.\nvar RANDOM = new utils.Lcg();\n\n// Encoding tap (shared for performance).\nvar TAP = new Tap(Buffer.allocUnsafeSlow(1024));\n\n// Path prefix for validity checks (shared for performance).\nvar PATH = [];\n\n// Currently active logical type, used for name redirection.\nvar LOGICAL_TYPE = null;\n\n\n/**\n * Schema parsing entry point.\n *\n * It isn't exposed directly but called from `parse` inside `index.js` (node)\n * or `avro.js` (browserify) which each add convenience functionality.\n *\n */\nfunction createType(attrs, opts) {\n  if (attrs instanceof Type) {\n    return attrs;\n  }\n\n  opts = getOpts(attrs, opts);\n\n  var type;\n  if (typeof attrs == 'string') { // Type reference.\n    if (opts.namespace && !~attrs.indexOf('.') && !isPrimitive(attrs)) {\n      attrs = opts.namespace + '.' + attrs;\n    }\n    type = opts.registry[attrs];\n    if (type) {\n      // Type was already defined, return it.\n      return type;\n    }\n    if (isPrimitive(attrs)) {\n      // Reference to a primitive type. These are also defined names by default\n      // so we create the appropriate type and it to the registry for future\n      // reference.\n      type = opts.registry[attrs] = createType({type: attrs}, opts);\n      return type;\n    }\n    throw new Error(f('undefined type name: %s', attrs));\n  }\n\n  if (opts.typeHook && (type = opts.typeHook(attrs, opts))) {\n    if (!(type instanceof Type)) {\n      throw new Error(f('invalid typehook return value: %j', type));\n    }\n    return type;\n  }\n\n  if (attrs.logicalType && !LOGICAL_TYPE) {\n    var DerivedType = opts.logicalTypes[attrs.logicalType];\n    if (DerivedType) {\n      var registry = {};\n      Object.keys(opts.registry).forEach(function (key) {\n        registry[key] = opts.registry[key];\n      });\n      try {\n        return new DerivedType(attrs, opts);\n      } catch (err) {\n        if (opts.assertLogicalTypes) {\n          throw err;\n        }\n        LOGICAL_TYPE = null;\n        opts.registry = registry; // In case any names were registered.\n      }\n    }\n  }\n\n  if (attrs instanceof Array) { // Union.\n    type = new UnionType(attrs, opts);\n  } else { // New type definition.\n    type = (function (typeName) {\n      var Type = TYPES[typeName];\n      if (Type === undefined) {\n        throw new Error(f('unknown type: %j', typeName));\n      }\n      return new Type(attrs, opts);\n    })(attrs.type);\n  }\n  return type;\n}\n\n/**\n * \"Abstract\" base Avro type class.\n *\n * This class' constructor will register any named types to support\n * recursive schemas.\n *\n * All type values are represented in memory similarly to their JSON\n * representation, except for `bytes` and `fixed` which are represented as\n * `Buffer`s. See individual subclasses for details.\n *\n */\nfunction Type(registry) {\n  var name = this._name;\n  var type = LOGICAL_TYPE || this;\n  LOGICAL_TYPE = null;\n\n  if (registry === undefined || name === undefined) {\n    return;\n  }\n\n  var prev = registry[name];\n  if (prev !== undefined) {\n    throw new Error(f('duplicate type name: %s', name));\n  }\n  registry[name] = type;\n}\n\nType.__reset = function (size) { TAP.buf = Buffer.allocUnsafeSlow(size); };\n\nType.prototype.createResolver = function (type, opts) {\n  if (!(type instanceof Type)) {\n    // More explicit error message than the \"incompatible type\" thrown\n    // otherwise (especially because of the overridden `toJSON` method).\n    throw new Error(f('not a type: %j', type));\n  }\n\n  if (type instanceof LogicalType && !(this instanceof LogicalType)) {\n    // Trying to read a logical type as a built-in: unwrap the logical type.\n    return this.createResolver(type._underlyingType, opts);\n  }\n\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n\n  var resolver, key;\n  if (this instanceof RecordType && type instanceof RecordType) {\n    key = this._name + ':' + type._name; // ':' is illegal in Avro type names.\n    resolver = opts.registry[key];\n    if (resolver) {\n      return resolver;\n    }\n  }\n\n  resolver = new Resolver(this);\n  if (key) { // Register resolver early for recursive schemas.\n    opts.registry[key] = resolver;\n  }\n\n  if (type instanceof UnionType) {\n    var resolvers = type._types.map(function (t) {\n      return this.createResolver(t, opts);\n    }, this);\n    resolver._read = function (tap) {\n      var index = tap.readLong();\n      var resolver = resolvers[index];\n      if (resolver === undefined) {\n        throw new Error(f('invalid union index: %s', index));\n      }\n      return resolvers[index]._read(tap);\n    };\n  } else {\n    this._updateResolver(resolver, type, opts);\n  }\n\n  if (!resolver._read) {\n    throw new Error(f('cannot read %s as %s', type, this));\n  }\n  return resolver;\n};\n\nType.prototype.decode = function (buf, pos, resolver) {\n  var tap = new Tap(buf);\n  tap.pos = pos | 0;\n  var val = readValue(this, tap, resolver);\n  if (!tap.isValid()) {\n    return {value: undefined, offset: -1};\n  }\n  return {value: val, offset: tap.pos};\n};\n\nType.prototype.encode = function (val, buf, pos) {\n  var tap = new Tap(buf);\n  tap.pos = pos | 0;\n  this._write(tap, val);\n  if (!tap.isValid()) {\n    // Don't throw as there is no way to predict this. We also return the\n    // number of missing bytes to ease resizing.\n    return buf.length - tap.pos;\n  }\n  return tap.pos;\n};\n\nType.prototype.fromBuffer = function (buf, resolver, noCheck) {\n  var tap = new Tap(buf);\n  var val = readValue(this, tap, resolver, noCheck);\n  if (!tap.isValid()) {\n    throw new Error('truncated buffer');\n  }\n  if (!noCheck && tap.pos < buf.length) {\n    throw new Error('trailing data');\n  }\n  return val;\n};\n\nType.prototype.toBuffer = function (val) {\n  TAP.pos = 0;\n  this._write(TAP, val);\n  if (!TAP.isValid()) {\n    Type.__reset(2 * TAP.pos);\n    TAP.pos = 0;\n    this._write(TAP, val);\n  }\n  var buf = Buffer.alloc(TAP.pos);\n  TAP.buf.copy(buf, 0, 0, TAP.pos);\n  return buf;\n};\n\nType.prototype.fromString = function (str) {\n  return this._copy(JSON.parse(str), {coerce: 2});\n};\n\nType.prototype.toString = function (val) {\n  if (val === undefined) {\n    // Consistent behavior with standard `toString` expectations.\n    return this.getSchema(true);\n  }\n  return JSON.stringify(this._copy(val, {coerce: 3}));\n};\n\nType.prototype.clone = function (val, opts) {\n  if (opts) {\n    opts = {\n      coerce: !!opts.coerceBuffers | 0, // Coerce JSON to Buffer.\n      fieldHook: opts.fieldHook,\n      wrap: !!opts.wrapUnions | 0 // Wrap first match into union.\n    };\n  }\n  return this._copy(val, opts);\n};\n\nType.prototype.isValid = function (val, opts) {\n  while (PATH.length) {\n    // In case the previous `isValid` call didn't complete successfully (e.g.\n    // if an exception was thrown, but then caught in client code), `PATH`\n    // might be non-empty, we must manually clear it.\n    PATH.pop();\n  }\n  return this._check(val, opts && opts.errorHook);\n};\n\nType.prototype.compareBuffers = function (buf1, buf2) {\n  return this._match(new Tap(buf1), new Tap(buf2));\n};\n\nType.prototype.getName = function (noRef) {\n  return noRef ? getTypeName(this) : this._name;\n};\n\nType.prototype.getSchema = function (noDeref) {\n  return stringify(this, noDeref);\n};\n\nType.prototype.getFingerprint = function (algorithm) {\n  return utils.getHash(this.getSchema(), algorithm);\n};\n\nType.prototype.inspect = function () {\n  if (this instanceof PrimitiveType) {\n    return f('<%s>', this.constructor.name);\n  } else {\n    var obj = JSON.parse(this.getSchema(true)); // Slow, only for debugging.\n    if (typeof obj == 'object') {\n      obj.type = undefined; // Would be redundant with constructor name.\n    }\n    return f('<%s %j>', this.constructor.name, obj);\n  }\n};\n\nType.prototype._check = utils.abstractFunction;\nType.prototype._copy = utils.abstractFunction;\nType.prototype._match = utils.abstractFunction;\nType.prototype._read = utils.abstractFunction;\nType.prototype._skip = utils.abstractFunction;\nType.prototype._updateResolver = utils.abstractFunction;\nType.prototype._write = utils.abstractFunction;\nType.prototype.compare = utils.abstractFunction;\nType.prototype.random = utils.abstractFunction;\n\n// Implementations.\n\n/**\n * Base primitive Avro type.\n *\n * Most of the primitive types share the same cloning and resolution\n * mechanisms, provided by this class. This class also lets us conveniently\n * check whether a type is a primitive using `instanceof`.\n *\n */\nfunction PrimitiveType() { Type.call(this); }\nutil.inherits(PrimitiveType, Type);\nPrimitiveType.prototype._updateResolver = function (resolver, type) {\n  if (type.constructor === this.constructor) {\n    resolver._read = this._read;\n  }\n};\nPrimitiveType.prototype._copy = function (val) {\n  this._check(val, throwInvalidError);\n  return val;\n};\nPrimitiveType.prototype.compare = utils.compare;\n\n/**\n * Nulls.\n *\n */\nfunction NullType() { PrimitiveType.call(this); }\nutil.inherits(NullType, PrimitiveType);\nNullType.prototype._check = function (val, cb) {\n  var b = val === null;\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\nNullType.prototype._read = function () { return null; };\nNullType.prototype._skip = function () {};\nNullType.prototype._write = function (tap, val) {\n  if (val !== null) {\n    throwInvalidError(null, val, this);\n  }\n};\nNullType.prototype._match = function () { return 0; };\nNullType.prototype.compare = NullType.prototype._match;\nNullType.prototype.random = NullType.prototype._read;\nNullType.prototype.toJSON = function () { return 'null'; };\n\n/**\n * Booleans.\n *\n */\nfunction BooleanType() { PrimitiveType.call(this); }\nutil.inherits(BooleanType, PrimitiveType);\nBooleanType.prototype._check = function (val, cb) {\n  var b = typeof val == 'boolean';\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\nBooleanType.prototype._read = function (tap) { return tap.readBoolean(); };\nBooleanType.prototype._skip = function (tap) { tap.skipBoolean(); };\nBooleanType.prototype._write = function (tap, val) {\n  if (typeof val != 'boolean') {\n    throwInvalidError(null, val, this);\n  }\n  tap.writeBoolean(val);\n};\nBooleanType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBoolean(tap2);\n};\nBooleanType.prototype.random = function () { return RANDOM.nextBoolean(); };\nBooleanType.prototype.toJSON = function () { return 'boolean'; };\n\n/**\n * Integers.\n *\n */\nfunction IntType() { PrimitiveType.call(this); }\nutil.inherits(IntType, PrimitiveType);\nIntType.prototype._check = function (val, cb) {\n  var b = val === (val | 0);\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\nIntType.prototype._read = function (tap) { return tap.readInt(); };\nIntType.prototype._skip = function (tap) { tap.skipInt(); };\nIntType.prototype._write = function (tap, val) {\n  if (val !== (val | 0)) {\n    throwInvalidError(null, val, this);\n  }\n  tap.writeInt(val);\n};\nIntType.prototype._match = function (tap1, tap2) {\n  return tap1.matchInt(tap2);\n};\nIntType.prototype.random = function () { return RANDOM.nextInt(1000) | 0; };\nIntType.prototype.toJSON = function () { return 'int'; };\n\n/**\n * Longs.\n *\n * We can't capture all the range unfortunately since JavaScript represents all\n * numbers internally as `double`s, so the default implementation plays safe\n * and throws rather than potentially silently change the data. See `using` or\n * `AbstractLongType` below for a way to implement a custom long type.\n *\n */\nfunction LongType() { PrimitiveType.call(this); }\nutil.inherits(LongType, PrimitiveType);\nLongType.prototype._check = function (val, cb) {\n  var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\nLongType.prototype._read = function (tap) {\n  var n = tap.readLong();\n  if (!isSafeLong(n)) {\n    throw new Error('potential precision loss');\n  }\n  return n;\n};\nLongType.prototype._skip = function (tap) { tap.skipLong(); };\nLongType.prototype._write = function (tap, val) {\n  if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {\n    throwInvalidError(null, val, this);\n  }\n  tap.writeLong(val);\n};\nLongType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\nLongType.prototype._updateResolver = function (resolver, type) {\n  if (type instanceof LongType || type instanceof IntType) {\n    resolver._read = type._read;\n  }\n};\nLongType.prototype.random = function () { return RANDOM.nextInt(); };\nLongType.prototype.toJSON = function () { return 'long'; };\nLongType.using = function (methods, noUnpack) {\n  methods = methods || {}; // Will give a more helpful error message.\n  // We map some of the methods to a different name to be able to intercept\n  // their input and output (otherwise we wouldn't be able to perform any\n  // unpacking logic, and the type wouldn't work when nested).\n  var mapping = {\n    toBuffer: '_toBuffer',\n    fromBuffer: '_fromBuffer',\n    fromJSON: '_fromJSON',\n    toJSON: '_toJSON',\n    isValid: '_isValid',\n    compare: 'compare'\n  };\n  var type = new AbstractLongType(noUnpack);\n  Object.keys(mapping).forEach(function (name) {\n    if (methods[name] === undefined) {\n      throw new Error(f('missing method implementation: %s', name));\n    }\n    type[mapping[name]] = methods[name];\n  });\n  return type;\n};\n\n/**\n * Floats.\n *\n */\nfunction FloatType() { PrimitiveType.call(this); }\nutil.inherits(FloatType, PrimitiveType);\nFloatType.prototype._check = function (val, cb) {\n  var b = typeof val == 'number';\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\nFloatType.prototype._read = function (tap) { return tap.readFloat(); };\nFloatType.prototype._skip = function (tap) { tap.skipFloat(); };\nFloatType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(null, val, this);\n  }\n  tap.writeFloat(val);\n};\nFloatType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFloat(tap2);\n};\nFloatType.prototype._updateResolver = function (resolver, type) {\n  if (\n    type instanceof FloatType ||\n    type instanceof LongType ||\n    type instanceof IntType\n  ) {\n    resolver._read = type._read;\n  }\n};\nFloatType.prototype.random = function () { return RANDOM.nextFloat(1e3); };\nFloatType.prototype.toJSON = function () { return 'float'; };\n\n/**\n * Doubles.\n *\n */\nfunction DoubleType() { PrimitiveType.call(this); }\nutil.inherits(DoubleType, PrimitiveType);\nDoubleType.prototype._check = function (val, cb) {\n  var b = typeof val == 'number';\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\nDoubleType.prototype._read = function (tap) { return tap.readDouble(); };\nDoubleType.prototype._skip = function (tap) { tap.skipDouble(); };\nDoubleType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(null, val, this);\n  }\n  tap.writeDouble(val);\n};\nDoubleType.prototype._match = function (tap1, tap2) {\n  return tap1.matchDouble(tap2);\n};\nDoubleType.prototype._updateResolver = function (resolver, type) {\n  if (\n    type instanceof DoubleType ||\n    type instanceof FloatType ||\n    type instanceof LongType ||\n    type instanceof IntType\n  ) {\n    resolver._read = type._read;\n  }\n};\nDoubleType.prototype.random = function () { return RANDOM.nextFloat(); };\nDoubleType.prototype.toJSON = function () { return 'double'; };\n\n/**\n * Strings.\n *\n */\nfunction StringType() { PrimitiveType.call(this); }\nutil.inherits(StringType, PrimitiveType);\nStringType.prototype._check = function (val, cb) {\n  var b = typeof val == 'string';\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\nStringType.prototype._read = function (tap) { return tap.readString(); };\nStringType.prototype._skip = function (tap) { tap.skipString(); };\nStringType.prototype._write = function (tap, val) {\n  if (typeof val != 'string') {\n    throwInvalidError(null, val, this);\n  }\n  tap.writeString(val);\n};\nStringType.prototype._match = function (tap1, tap2) {\n  return tap1.matchString(tap2);\n};\nStringType.prototype._updateResolver = function (resolver, type) {\n  if (type instanceof StringType || type instanceof BytesType) {\n    resolver._read = this._read;\n  }\n};\nStringType.prototype.random = function () {\n  return RANDOM.nextString(RANDOM.nextInt(32));\n};\nStringType.prototype.toJSON = function () { return 'string'; };\n\n/**\n * Bytes.\n *\n * These are represented in memory as `Buffer`s rather than binary-encoded\n * strings. This is more efficient (when decoding/encoding from bytes, the\n * common use-case), idiomatic, and convenient.\n *\n * Note the coercion in `_copy`.\n *\n */\nfunction BytesType() { PrimitiveType.call(this); }\nutil.inherits(BytesType, PrimitiveType);\nBytesType.prototype._check = function (val, cb) {\n  var b = Buffer.isBuffer(val);\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\nBytesType.prototype._read = function (tap) { return tap.readBytes(); };\nBytesType.prototype._skip = function (tap) { tap.skipBytes(); };\nBytesType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val)) {\n    throwInvalidError(null, val, this);\n  }\n  tap.writeBytes(val);\n};\nBytesType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBytes(tap2);\n};\nBytesType.prototype._updateResolver = StringType.prototype._updateResolver;\nBytesType.prototype._copy = function (obj, opts) {\n  var buf;\n  switch ((opts && opts.coerce) | 0) {\n    case 3: // Coerce buffers to strings.\n      this._check(obj, throwInvalidError);\n      return obj.toString('binary');\n    case 2: // Coerce strings to buffers.\n      if (typeof obj != 'string') {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = Buffer.from(obj, 'binary');\n      this._check(buf, throwInvalidError);\n      return buf;\n    case 1: // Coerce buffer JSON representation to buffers.\n      if (!obj || obj.type !== 'Buffer' || !(obj.data instanceof Array)) {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = Buffer.from(obj.data);\n      this._check(buf, throwInvalidError);\n      return buf;\n    default: // Copy buffer.\n      this._check(obj, throwInvalidError);\n      return Buffer.from(obj);\n  }\n};\nBytesType.prototype.compare = Buffer.compare;\nBytesType.prototype.random = function () {\n  return RANDOM.nextBuffer(RANDOM.nextInt(32));\n};\nBytesType.prototype.toJSON = function () { return 'bytes'; };\n\n/**\n * Avro unions.\n *\n * Unions are represented in memory similarly to their JSON representation\n * (i.e. inside an object with single key the name of the contained type).\n *\n * This is not ideal, but is the most efficient way to unambiguously support\n * all unions. Here are a few reasons why the wrapping object is necessary:\n *\n * + Unions with multiple number types would have undefined behavior, unless\n *   numbers are wrapped (either everywhere, leading to large performance and\n *   convenience costs; or only when necessary inside unions, making it hard to\n *   understand when numbers are wrapped or not).\n * + Fixed types would have to be wrapped to be distinguished from bytes.\n * + Using record's constructor names would work (after a slight change to use\n *   the fully qualified name), but would mean that generic objects could no\n *   longer be valid records (making it inconvenient to do simple things like\n *   creating new records).\n *\n * Lore: In the past (until d304cab), there used to be an \"unwrapped union\n * type\" which directly exposed its values, without the wrapping object\n * (similarly to Avro's python implementation). It was removed to keep all\n * representations consistent and make this library simpler to understand\n * (conversions, e.g. for schema evolution, between representations were\n * particularly confusing). Encoding was also much slower (worst case\n * complexity linear in the number of types in the union).\n *\n */\nfunction UnionType(attrs, opts) {\n  if (!(attrs instanceof Array)) {\n    throw new Error(f('non-array union schema: %j', attrs));\n  }\n  if (!attrs.length) {\n    throw new Error('empty union');\n  }\n\n  opts = getOpts(attrs, opts);\n  Type.call(this);\n  this._types = attrs.map(function (obj) { return createType(obj, opts); });\n\n  this._indices = {};\n  this._types.forEach(function (type, i) {\n    if (type instanceof UnionType) {\n      throw new Error('unions cannot be directly nested');\n    }\n    var name = type._name || getTypeName(type);\n    if (this._indices[name] !== undefined) {\n      throw new Error(f('duplicate union name: %j', name));\n    }\n    this._indices[name] = i;\n  }, this);\n\n  this._constructors = this._types.map(function (type) {\n    // jshint -W054\n    var name = type._name || getTypeName(type);\n    if (name === 'null') {\n      return null;\n    }\n    var body;\n    if (~name.indexOf('.')) { // Qualified name.\n      body = 'this[\\'' + name + '\\'] = val;';\n    } else {\n      body = 'this.' + name + ' = val;';\n    }\n    return new Function('val', body);\n  });\n}\nutil.inherits(UnionType, Type);\n\nUnionType.prototype._check = function (val, cb) {\n  var b = false;\n  if (val === null) {\n    // Shortcut type lookup in this case.\n    b = this._indices['null'] !== undefined;\n  } else if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      // We require a single key here to ensure that writes are correct and\n      // efficient as soon as a record passes this check.\n      var name = keys[0];\n      var index = this._indices[name];\n      if (index !== undefined) {\n        PATH.push(name);\n        b = this._types[index]._check(val[name], cb);\n        PATH.pop();\n        return b;\n      }\n    }\n  }\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\n\nUnionType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var Class = this._constructors[index];\n  if (Class) {\n    return new Class(this._types[index]._read(tap));\n  } else if (Class === null) {\n    return null;\n  } else {\n    throw new Error(f('invalid union index: %s', index));\n  }\n};\n\nUnionType.prototype._skip = function (tap) {\n  this._types[tap.readLong()]._skip(tap);\n};\n\nUnionType.prototype._write = function (tap, val) {\n  var index, keys, name;\n  if (val === null) {\n    index = this._indices['null'];\n    if (index === undefined) {\n      throwInvalidError(null, val, this);\n    }\n    tap.writeLong(index);\n  } else {\n    keys = Object.keys(val);\n    if (keys.length === 1) {\n      name = keys[0];\n      index = this._indices[name];\n    }\n    if (index === undefined) {\n      throwInvalidError(null, val, this);\n    }\n    tap.writeLong(index);\n    this._types[index]._write(tap, val[name]);\n  }\n};\n\nUnionType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  if (n1 === n2) {\n    return this._types[n1]._match(tap1, tap2);\n  } else {\n    return n1 < n2 ? -1 : 1;\n  }\n};\n\nUnionType.prototype._updateResolver = function (resolver, type, opts) {\n  // jshint -W083\n  // (The loop exits after the first function is created.)\n  var i, l, typeResolver, Class;\n  for (i = 0, l = this._types.length; i < l; i++) {\n    try {\n      typeResolver = this._types[i].createResolver(type, opts);\n    } catch (err) {\n      continue;\n    }\n    Class = this._constructors[i];\n    if (Class) {\n      resolver._read = function (tap) {\n        return new Class(typeResolver._read(tap));\n      };\n    } else {\n      resolver._read = function () { return null; };\n    }\n    return;\n  }\n};\n\nUnionType.prototype._copy = function (val, opts) {\n  var wrap = opts && opts.wrap | 0;\n  if (wrap === 2) {\n    // Promote into first type (used for schema defaults).\n    if (val === null && this._constructors[0] === null) {\n      return null;\n    }\n    return new this._constructors[0](this._types[0]._copy(val, opts));\n  }\n  if (val === null && this._indices['null'] !== undefined) {\n    return null;\n  }\n\n  var i, l, obj;\n  if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      var name = keys[0];\n      i = this._indices[name];\n      if (i === undefined) {\n        // We are a bit more flexible than in `_check` here since we have\n        // to deal with other serializers being less strict, so we fall\n        // back to looking up unqualified names.\n        var j, type;\n        for (j = 0, l = this._types.length; j < l; j++) {\n          type = this._types[j];\n          if (type._name && name === unqualify(type._name)) {\n            i = j;\n            break;\n          }\n        }\n      }\n      if (i !== undefined) {\n        obj = this._types[i]._copy(val[name], opts);\n      }\n    }\n  }\n  if (wrap === 1 && obj === undefined) {\n    // Try promoting into first match (convenience, slow).\n    i = 0;\n    l = this._types.length;\n    while (i < l && obj === undefined) {\n      try {\n        obj = this._types[i]._copy(val, opts);\n      } catch (err) {\n        i++;\n      }\n    }\n  }\n  if (obj !== undefined) {\n    return new this._constructors[i](obj);\n  }\n  throwInvalidError(null, val, this);\n};\n\nUnionType.prototype.compare = function (val1, val2) {\n  var name1 = val1 === null ? 'null' : Object.keys(val1)[0];\n  var name2 = val2 === null ? 'null' : Object.keys(val2)[0];\n  var index = this._indices[name1];\n  if (name1 === name2) {\n    return name1 === 'null' ?\n      0 :\n      this._types[index].compare(val1[name1], val2[name1]);\n  } else {\n    return utils.compare(index, this._indices[name2]);\n  }\n};\n\nUnionType.prototype.getTypes = function () { return this._types.slice(); };\n\nUnionType.prototype.random = function () {\n  var index = RANDOM.nextInt(this._types.length);\n  var Class = this._constructors[index];\n  if (!Class) {\n    return null;\n  }\n  return new Class(this._types[index].random());\n};\n\nUnionType.prototype.toJSON = function () { return this._types; };\n\n/**\n * Avro enum type.\n *\n * Represented as strings (with allowed values from the set of symbols). Using\n * integers would be a reasonable option, but the performance boost is arguably\n * offset by the legibility cost and the extra deviation from the JSON encoding\n * convention.\n *\n * An integer representation can still be used (e.g. for compatibility with\n * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via\n * `parse`'s registry).\n *\n */\nfunction EnumType(attrs, opts) {\n  if (!(attrs.symbols instanceof Array) || !attrs.symbols.length) {\n    throw new Error(f('invalid %j enum symbols: %j', attrs.name, attrs));\n  }\n\n  opts = getOpts(attrs, opts);\n  var resolutions = resolveNames(attrs, opts.namespace);\n  this._name = resolutions.name;\n  this._symbols = attrs.symbols;\n  this._aliases = resolutions.aliases;\n  Type.call(this, opts.registry);\n\n  this._indices = {};\n  this._symbols.forEach(function (symbol, i) {\n    if (!NAME_PATTERN.test(symbol)) {\n      throw new Error(f('invalid %s symbol: %j', this, symbol));\n    }\n    if (this._indices[symbol] !== undefined) {\n      throw new Error(f('duplicate %s symbol: %j', this, symbol));\n    }\n    this._indices[symbol] = i;\n  }, this);\n}\nutil.inherits(EnumType, Type);\n\nEnumType.prototype._check = function (val, cb) {\n  var b = this._indices[val] !== undefined;\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\n\nEnumType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var symbol = this._symbols[index];\n  if (symbol === undefined) {\n    throw new Error(f('invalid %s enum index: %s', this._name, index));\n  }\n  return symbol;\n};\n\nEnumType.prototype._skip = function (tap) { tap.skipLong(); };\n\nEnumType.prototype._write = function (tap, val) {\n  var index = this._indices[val];\n  if (index === undefined) {\n    throwInvalidError(null, val, this);\n  }\n  tap.writeLong(index);\n};\n\nEnumType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\n\nEnumType.prototype.compare = function (val1, val2) {\n  return utils.compare(this._indices[val1], this._indices[val2]);\n};\n\nEnumType.prototype._updateResolver = function (resolver, type) {\n  var symbols = this._symbols;\n  if (\n    type instanceof EnumType &&\n    ~getAliases(this).indexOf(type._name) &&\n    type._symbols.every(function (s) { return ~symbols.indexOf(s); })\n  ) {\n    resolver._symbols = type._symbols;\n    resolver._read = type._read;\n  }\n};\n\nEnumType.prototype._copy = function (val) {\n  this._check(val, throwInvalidError);\n  return val;\n};\n\nEnumType.prototype.getAliases = function () { return this._aliases; };\n\nEnumType.prototype.getSymbols = function () { return this._symbols.slice(); };\n\nEnumType.prototype.random = function () {\n  return RANDOM.choice(this._symbols);\n};\n\nEnumType.prototype.toJSON = function () {\n  return {name: this._name, type: 'enum', symbols: this._symbols};\n};\n\n/**\n * Avro fixed type.\n *\n * Represented simply as a `Buffer`.\n *\n */\nfunction FixedType(attrs, opts) {\n  if (attrs.size !== (attrs.size | 0) || attrs.size < 1) {\n    throw new Error(f('invalid %j fixed size: %j', attrs.name, attrs.size));\n  }\n\n  opts = getOpts(attrs, opts);\n  var resolutions = resolveNames(attrs, opts.namespace);\n  this._name = resolutions.name;\n  this._size = attrs.size | 0;\n  this._aliases = resolutions.aliases;\n  Type.call(this, opts.registry);\n}\nutil.inherits(FixedType, Type);\n\nFixedType.prototype._check = function (val, cb) {\n  var b = Buffer.isBuffer(val) && val.length === this._size;\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\n\nFixedType.prototype._read = function (tap) {\n  return tap.readFixed(this._size);\n};\n\nFixedType.prototype._skip = function (tap) {\n  tap.skipFixed(this._size);\n};\n\nFixedType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val) || val.length !== this._size) {\n    throwInvalidError(null, val, this);\n  }\n  tap.writeFixed(val, this._size);\n};\n\nFixedType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFixed(tap2, this._size);\n};\n\nFixedType.prototype.compare = Buffer.compare;\n\nFixedType.prototype._updateResolver = function (resolver, type) {\n  if (\n    type instanceof FixedType &&\n    this._size === type._size &&\n    ~getAliases(this).indexOf(type._name)\n  ) {\n    resolver._size = this._size;\n    resolver._read = this._read;\n  }\n};\n\nFixedType.prototype._copy = BytesType.prototype._copy;\n\nFixedType.prototype.getAliases = function () { return this._aliases; };\n\nFixedType.prototype.getSize = function () { return this._size; };\n\nFixedType.prototype.random = function () {\n  return RANDOM.nextBuffer(this._size);\n};\n\nFixedType.prototype.toJSON = function () {\n  return {name: this._name, type: 'fixed', size: this._size};\n};\n\n/**\n * Avro map.\n *\n * Represented as vanilla objects.\n *\n */\nfunction MapType(attrs, opts) {\n  if (!attrs.values) {\n    throw new Error(f('missing map values: %j', attrs));\n  }\n\n  opts = getOpts(attrs, opts);\n  Type.call(this);\n  this._values = createType(attrs.values, opts);\n}\nutil.inherits(MapType, Type);\n\nMapType.prototype.getValuesType = function () { return this._values; };\n\nMapType.prototype._check = function (val, cb) {\n  if (!val || typeof val != 'object' || val instanceof Array) {\n    if (cb) {\n      cb(PATH.slice(), val, this);\n    }\n    return false;\n  }\n\n  var keys = Object.keys(val);\n  var b = true;\n  var i, l, j, key;\n  if (cb) {\n    // Slow path.\n    j = PATH.length;\n    PATH.push('');\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = PATH[j] = keys[i];\n      if (!this._values._check(val[key], cb)) {\n        b = false;\n      }\n    }\n    PATH.pop();\n  } else {\n    for (i = 0, l = keys.length; i < l; i++) {\n      if (!this._values._check(val[keys[i]], cb)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\n\nMapType.prototype._read = function (tap) {\n  var values = this._values;\n  var val = {};\n  var n;\n  while ((n = readArraySize(tap))) {\n    while (n--) {\n      var key = tap.readString();\n      val[key] = values._read(tap);\n    }\n  }\n  return val;\n};\n\nMapType.prototype._skip = function (tap) {\n  var values = this._values;\n  var len, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        tap.skipString();\n        values._skip(tap);\n      }\n    }\n  }\n};\n\nMapType.prototype._write = function (tap, val) {\n  if (!val || typeof val != 'object' || val instanceof Array) {\n    throwInvalidError(null, val, this);\n  }\n\n  var values = this._values;\n  var keys = Object.keys(val);\n  var n = keys.length;\n  var i, key;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      key = keys[i];\n      tap.writeString(key);\n      values._write(tap, val[key]);\n    }\n  }\n  tap.writeLong(0);\n};\n\nMapType.prototype._match = function () {\n  throw new Error('maps cannot be compared');\n};\n\nMapType.prototype._updateResolver = function (resolver, type, opts) {\n  if (type instanceof MapType) {\n    resolver._values = this._values.createResolver(type._values, opts);\n    resolver._read = this._read;\n  }\n};\n\nMapType.prototype._copy = function (val, opts) {\n  if (val && typeof val == 'object' && !(val instanceof Array)) {\n    var values = this._values;\n    var keys = Object.keys(val);\n    var i, l, key;\n    var copy = {};\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      copy[key] = values._copy(val[key], opts);\n    }\n    return copy;\n  }\n  throwInvalidError(null, val, this);\n};\n\nMapType.prototype.compare = MapType.prototype._match;\n\nMapType.prototype.random = function () {\n  var val = {};\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    val[RANDOM.nextString(RANDOM.nextInt(20))] = this._values.random();\n  }\n  return val;\n};\n\nMapType.prototype.toJSON = function () {\n  return {type: 'map', values: this._values};\n};\n\n/**\n * Avro array.\n *\n * Represented as vanilla arrays.\n *\n */\nfunction ArrayType(attrs, opts) {\n  if (!attrs.items) {\n    throw new Error(f('missing array items: %j', attrs));\n  }\n\n  opts = getOpts(attrs, opts);\n\n  this._items = createType(attrs.items, opts);\n  Type.call(this);\n}\nutil.inherits(ArrayType, Type);\n\nArrayType.prototype._check = function (val, cb) {\n  if (!(val instanceof Array)) {\n    if (cb) {\n      cb(PATH.slice(), val, this);\n    }\n    return false;\n  }\n\n  var b = true;\n  var i, l, j;\n  if (cb) {\n    // Slow path.\n    j = PATH.length;\n    PATH.push('');\n    for (i = 0, l = val.length; i < l; i++) {\n      PATH[j] = '' + i;\n      if (!this._items._check(val[i], cb)) {\n        b = false;\n      }\n    }\n    PATH.pop();\n  } else {\n    for (i = 0, l = val.length; i < l; i++) {\n      if (!this._items._check(val[i], cb)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\n\nArrayType.prototype._read = function (tap) {\n  var items = this._items;\n  var val = [];\n  var n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      n = -n;\n      tap.skipLong(); // Skip size.\n    }\n    while (n--) {\n      val.push(items._read(tap));\n    }\n  }\n  return val;\n};\n\nArrayType.prototype._skip = function (tap) {\n  var len, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        this._items._skip(tap);\n      }\n    }\n  }\n};\n\nArrayType.prototype._write = function (tap, val) {\n  if (!(val instanceof Array)) {\n    throwInvalidError(null, val, this);\n  }\n\n  var n = val.length;\n  var i;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      this._items._write(tap, val[i]);\n    }\n  }\n  tap.writeLong(0);\n};\n\nArrayType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  var f;\n  while (n1 && n2) {\n    f = this._items._match(tap1, tap2);\n    if (f) {\n      return f;\n    }\n    if (!--n1) {\n      n1 = readArraySize(tap1);\n    }\n    if (!--n2) {\n      n2 = readArraySize(tap2);\n    }\n  }\n  return utils.compare(n1, n2);\n};\n\nArrayType.prototype._updateResolver = function (resolver, type, opts) {\n  if (type instanceof ArrayType) {\n    resolver._items = this._items.createResolver(type._items, opts);\n    resolver._read = this._read;\n  }\n};\n\nArrayType.prototype._copy = function (val, opts) {\n  if (!(val instanceof Array)) {\n    throwInvalidError(null, val, this);\n  }\n  var items = [];\n  var i, l;\n  for (i = 0, l = val.length; i < l; i++) {\n    items.push(this._items._copy(val[i], opts));\n  }\n  return items;\n};\n\nArrayType.prototype.compare = function (val1, val2) {\n  var n1 = val1.length;\n  var n2 = val2.length;\n  var i, l, f;\n  for (i = 0, l = Math.min(n1, n2); i < l; i++) {\n    if ((f = this._items.compare(val1[i], val2[i]))) {\n      return f;\n    }\n  }\n  return utils.compare(n1, n2);\n};\n\nArrayType.prototype.getItemsType = function () { return this._items; };\n\nArrayType.prototype.random = function () {\n  var arr = [];\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    arr.push(this._items.random());\n  }\n  return arr;\n};\n\nArrayType.prototype.toJSON = function () {\n  return {type: 'array', items: this._items};\n};\n\n/**\n * Avro record.\n *\n * Values are represented as instances of a programmatically generated\n * constructor (similar to a \"specific record\"), available via the\n * `getRecordConstructor` method. This \"specific record class\" gives\n * significant speedups over using generics objects.\n *\n * Note that vanilla objects are still accepted as valid as long as their\n * fields match (this makes it much more convenient to do simple things like\n * update nested records).\n *\n */\nfunction RecordType(attrs, opts) {\n  opts = getOpts(attrs, opts);\n\n  var resolutions = resolveNames(attrs, opts.namespace);\n  this._name = resolutions.name;\n  this._aliases = resolutions.aliases;\n  this._type = attrs.type;\n  // Requests shouldn't be registered since their name is only a placeholder.\n  Type.call(this, this._type === 'request' ? undefined : opts.registry);\n\n  if (!(attrs.fields instanceof Array)) {\n    throw new Error(f('non-array %s fields', this._name));\n  }\n  this._fields = attrs.fields.map(function (f) {\n    return new Field(f, opts);\n  });\n  if (utils.hasDuplicates(attrs.fields, function (f) { return f.name; })) {\n    throw new Error(f('duplicate %s field name', this._name));\n  }\n\n  var isError = attrs.type === 'error';\n  this._constructor = this._createConstructor(isError);\n  this._read = this._createReader();\n  this._skip = this._createSkipper();\n  this._write = this._createWriter();\n  this._check = this._createChecker();\n}\nutil.inherits(RecordType, Type);\n\nRecordType.prototype._createConstructor = function (isError) {\n  // jshint -W054\n  var outerArgs = [];\n  var innerArgs = [];\n  var ds = []; // Defaults.\n  var innerBody = isError ? '  Error.call(this);\\n' : '';\n  // Not calling `Error.captureStackTrace` because this wouldn't be compatible\n  // with browsers other than Chrome.\n  var i, l, field, name, getDefault;\n  for (i = 0, l = this._fields.length; i < l; i++) {\n    field = this._fields[i];\n    getDefault = field.getDefault;\n    name = field._name;\n    innerArgs.push('v' + i);\n    innerBody += '  ';\n    if (getDefault() === undefined) {\n      innerBody += 'this.' + name + ' = v' + i + ';\\n';\n    } else {\n      innerBody += 'if (v' + i + ' === undefined) { ';\n      innerBody += 'this.' + name + ' = d' + ds.length + '(); ';\n      innerBody += '} else { this.' + name + ' = v' + i + '; }\\n';\n      outerArgs.push('d' + ds.length);\n      ds.push(getDefault);\n    }\n  }\n  var outerBody = 'return function ' + unqualify(this._name) + '(';\n  outerBody += innerArgs.join() + ') {\\n' + innerBody + '};';\n  var Record = new Function(outerArgs.join(), outerBody).apply(undefined, ds);\n\n  var self = this;\n  Record.getType = function () { return self; };\n  Record.prototype = {\n    constructor: Record,\n    $clone: function (opts) { return self.clone(this, opts); },\n    $compare: function (val) { return self.compare(this, val); },\n    $getType: Record.getType,\n    $isValid: function (opts) { return self.isValid(this, opts); },\n    $toBuffer: function () { return self.toBuffer(this); },\n    $toString: function (noCheck) { return self.toString(this, noCheck); }\n  };\n  // The names of these properties added to the prototype are prefixed with `$`\n  // because it is an invalid property name in Avro but not in JavaScript.\n  // (This way we are guaranteed not to be stepped over!)\n  if (isError) {\n    util.inherits(Record, Error);\n    // Not setting the name on the prototype to be consistent with how object\n    // fields are mapped to (only if defined in the schema as a field).\n  }\n\n  return Record;\n};\n\nRecordType.prototype._createChecker = function () {\n  // jshint -W054\n  var names = ['t', 'P'];\n  var values = [this, PATH];\n  var body = 'return function check' + unqualify(this._name) + '(val, cb) {\\n';\n  body += '  if (val === null || typeof val != \\'object\\') {\\n';\n  body += '    if (cb) { cb(P.slice(), val, t); }\\n';\n  body += '    return false;\\n';\n  body += '  }\\n';\n  if (!this._fields.length) {\n    // Special case, empty record. We handle this directly.\n    body += '  return true;\\n';\n  } else {\n    for (i = 0, l = this._fields.length; i < l; i++) {\n      field = this._fields[i];\n      names.push('t' + i);\n      values.push(field._type);\n      if (field.getDefault() !== undefined) {\n        body += '  var v' + i + ' = val.' + field._name + ';\\n';\n      }\n    }\n    body += '  if (cb) {\\n';\n    body += '    var b = 1;\\n';\n    body += '    var j = P.length;\\n';\n    body += '    P.push(\\'\\');\\n';\n    var i, l, field;\n    for (i = 0, l = this._fields.length; i < l; i++) {\n      field = this._fields[i];\n      body += '    P[j] = \\'' + field._name + '\\';\\n';\n      if (field.getDefault() === undefined) {\n        body += '    b &= t' + i + '._check(val.' + field._name + ', cb);\\n';\n      } else {\n        body += '    b &= v' + i + ' === undefined || ';\n        body += 't' + i + '._check(v' + i + ', cb);\\n';\n      }\n    }\n    body += '    P.pop();\\n';\n    body += '    return !!b;\\n';\n    body += '  } else {\\n    return (\\n      ';\n    body += this._fields.map(function (field, i) {\n      if (field.getDefault() === undefined) {\n        return 't' + i + '._check(val.' + field._name + ')';\n      } else {\n        return '(v' + i + ' === undefined || t' + i + '._check(v' + i + '))';\n      }\n    }).join(' &&\\n      ');\n    body += '\\n    );\\n  }\\n';\n  }\n  body += '};';\n  return new Function(names.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._createReader = function () {\n  // jshint -W054\n  var uname = unqualify(this._name);\n  var names = [];\n  var values = [this._constructor];\n  var i, l;\n  for (i = 0, l = this._fields.length; i < l; i++) {\n    names.push('t' + i);\n    values.push(this._fields[i]._type);\n  }\n  var body = 'return function read' + uname + '(tap) {\\n';\n  body += '  return new ' + uname + '(';\n  body += names.map(function (t) { return t + '._read(tap)'; }).join();\n  body += ');\\n};';\n  names.unshift(uname);\n  // We can do this since the JS spec guarantees that function arguments are\n  // evaluated from left to right.\n  return new Function(names.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._createSkipper = function () {\n  // jshint -W054\n  var args = [];\n  var body = 'return function skip' + unqualify(this._name) + '(tap) {\\n';\n  var values = [];\n  var i, l;\n  for (i = 0, l = this._fields.length; i < l; i++) {\n    args.push('t' + i);\n    values.push(this._fields[i]._type);\n    body += '  t' + i + '._skip(tap);\\n';\n  }\n  body += '}';\n  return new Function(args.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._createWriter = function () {\n  // jshint -W054\n  // We still do default handling here, in case a normal JS object is passed.\n  var args = [];\n  var body = 'return function write' + unqualify(this._name) + '(tap, val) {\\n';\n  var values = [];\n  var i, l, field, value;\n  for (i = 0, l = this._fields.length; i < l; i++) {\n    field = this._fields[i];\n    args.push('t' + i);\n    values.push(field._type);\n    body += '  ';\n    if (field.getDefault() === undefined) {\n      body += 't' + i + '._write(tap, val.' + field._name + ');\\n';\n    } else {\n      value = field._type.toBuffer(field.getDefault()).toString('binary');\n      // Convert the default value to a binary string ahead of time. We aren't\n      // converting it to a buffer to avoid retaining too much memory. If we\n      // had our own buffer pool, this could be an idea in the future.\n      args.push('d' + i);\n      values.push(value);\n      body += 'var v' + i + ' = val.' + field._name + '; ';\n      body += 'if (v' + i + ' === undefined) { ';\n      body += 'tap.writeBinary(d' + i + ', ' + value.length + ');';\n      body += ' } else { t' + i + '._write(tap, v' + i + '); }\\n';\n    }\n  }\n  body += '}';\n  return new Function(args.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._updateResolver = function (resolver, type, opts) {\n  // jshint -W054\n  if (!~getAliases(this).indexOf(type._name)) {\n    throw new Error(f('no alias for %s in %s', type._name, this._name));\n  }\n\n  var rFields = this._fields;\n  var wFields = type._fields;\n  var wFieldsMap = utils.toMap(wFields, function (f) { return f._name; });\n\n  var innerArgs = []; // Arguments for reader constructor.\n  var resolvers = {}; // Resolvers keyed by writer field name.\n  var i, j, field, name, names, matches;\n  for (i = 0; i < rFields.length; i++) {\n    field = rFields[i];\n    names = getAliases(field);\n    matches = [];\n    for (j = 0; j < names.length; j++) {\n      name = names[j];\n      if (wFieldsMap[name]) {\n        matches.push(name);\n      }\n    }\n    if (matches.length > 1) {\n      throw new Error(f('multiple matches for %s', field.name));\n    }\n    if (!matches.length) {\n      if (field.getDefault() === undefined) {\n        throw new Error(f('no match for default-less %s', field.name));\n      }\n      innerArgs.push('undefined');\n    } else {\n      name = matches[0];\n      resolvers[name] = {\n        resolver: field._type.createResolver(wFieldsMap[name]._type, opts),\n        name: field._name // Reader field name.\n      };\n      innerArgs.push(field._name);\n    }\n  }\n\n  // See if we can add a bypass for unused fields at the end of the record.\n  var lazyIndex = -1;\n  i = wFields.length;\n  while (i && resolvers[wFields[--i]._name] === undefined) {\n    lazyIndex = i;\n  }\n\n  var uname = unqualify(this._name);\n  var args = [uname];\n  var values = [this._constructor];\n  var body = '  return function read' + uname + '(tap,lazy) {\\n';\n  for (i = 0; i < wFields.length; i++) {\n    if (i === lazyIndex) {\n      body += '  if (!lazy) {\\n';\n    }\n    field = type._fields[i];\n    name = field._name;\n    body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';\n    if (resolvers[name] === undefined) {\n      args.push('t' + i);\n      values.push(field._type);\n      body += 't' + i + '._skip(tap);\\n';\n    } else {\n      args.push('t' + i);\n      values.push(resolvers[name].resolver);\n      body += 'var ' + resolvers[name].name + ' = ';\n      body += 't' + i + '._read(tap);\\n';\n    }\n  }\n  if (~lazyIndex) {\n    body += '  }\\n';\n  }\n  body +=  '  return new ' + uname + '(' + innerArgs.join() + ');\\n};';\n\n  resolver._read = new Function(args.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._match = function (tap1, tap2) {\n  var fields = this._fields;\n  var i, l, field, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    order = field._order;\n    type = field._type;\n    if (order) {\n      order *= type._match(tap1, tap2);\n      if (order) {\n        return order;\n      }\n    } else {\n      type._skip(tap1);\n      type._skip(tap2);\n    }\n  }\n  return 0;\n};\n\nRecordType.prototype._copy = function (val, opts) {\n  // jshint -W058\n  var hook = opts && opts.fieldHook;\n  var values = [undefined];\n  var i, l, field, value;\n  for (i = 0, l = this._fields.length; i < l; i++) {\n    field = this._fields[i];\n    value = field._type._copy(typeof val[field._name] == 'undefined' ? field.getDefault() : val[field._name], opts);\n    if (hook) {\n      value = hook(field, value, this);\n    }\n    values.push(value);\n  }\n  return new (this._constructor.bind.apply(this._constructor, values));\n};\n\nRecordType.prototype.compare = function (val1, val2) {\n  var fields = this._fields;\n  var i, l, field, name, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    name = field._name;\n    order = field._order;\n    type = field._type;\n    if (order) {\n      order *= type.compare(val1[name], val2[name]);\n      if (order) {\n        return order;\n      }\n    }\n  }\n  return 0;\n};\n\nRecordType.prototype.random = function () {\n  // jshint -W058\n  var fields = this._fields.map(function (f) { return f._type.random(); });\n  fields.unshift(undefined);\n  return new (this._constructor.bind.apply(this._constructor, fields));\n};\n\nRecordType.prototype.getAliases = function () { return this._aliases; };\n\nRecordType.prototype.getFields = function () { return this._fields.slice(); };\n\nRecordType.prototype.getRecordConstructor = function () {\n  return this._constructor;\n};\n\nRecordType.prototype.toJSON = function () {\n  return {name: this._name, type: 'record', fields: this._fields};\n};\n\n/**\n * Derived type abstract class.\n *\n */\nfunction LogicalType(attrs, opts, Types) {\n  Type.call(this);\n  LOGICAL_TYPE = this;\n  this._underlyingType = createType(attrs, opts);\n\n  // Convenience type check.\n  if (Types && !~Types.indexOf(this._underlyingType.constructor)) {\n    var lType = attrs.logicalType;\n    var uType = this._underlyingType;\n    throw new Error(f('invalid underlying type for %s: %s', lType, uType));\n  }\n}\nutil.inherits(LogicalType, Type);\n\nLogicalType.prototype.getUnderlyingType = function () {\n  return this._underlyingType;\n};\n\nLogicalType.prototype._read = function (tap) {\n  return this._fromValue(this._underlyingType._read(tap));\n};\n\nLogicalType.prototype._write = function (tap, any) {\n  this._underlyingType._write(tap, this._toValue(any));\n};\n\nLogicalType.prototype._check = function (any, cb) {\n  var val;\n  try {\n    val = this._toValue(any);\n  } catch (err) {\n    if (cb) {\n      cb(PATH.slice(), any, this);\n    }\n    return false;\n  }\n  return this._underlyingType._check(val, cb);\n};\n\nLogicalType.prototype._copy = function (any, opts) {\n  var type = this._underlyingType;\n  switch (opts && opts.coerce) {\n    case 3: // To string.\n      return type._copy(this._toValue(any), opts);\n    case 2: // From string.\n      return this._fromValue(type._copy(any, opts));\n    default: // Normal copy.\n      return this._fromValue(type._copy(this._toValue(any), opts));\n  }\n};\n\nLogicalType.prototype._updateResolver = function (resolver, type, opts) {\n  var _fromValue = this._resolve(type, opts);\n  if (_fromValue) {\n    resolver._read = function (tap) { return _fromValue(type._read(tap)); };\n  }\n};\n\nLogicalType.prototype.random = function () {\n  return this._fromValue(this._underlyingType.random());\n};\n\nLogicalType.prototype.compare = function (obj1, obj2) {\n  var val1 = this._toValue(obj1);\n  var val2 = this._toValue(obj2);\n  return this._underlyingType.compare(val1, val2);\n};\n\nLogicalType.prototype.toJSON = function () {\n  return this._underlyingType.toJSON();\n};\n\n// Methods to be implemented.\nLogicalType.prototype._fromValue = utils.abstractFunction;\nLogicalType.prototype._toValue = utils.abstractFunction;\nLogicalType.prototype._resolve = utils.abstractFunction;\n\n\n// General helpers.\n\n/**\n * Customizable long.\n *\n * This allows support of arbitrarily large long (e.g. larger than\n * `Number.MAX_SAFE_INTEGER`). See `LongType.using` method above.\n *\n */\nfunction AbstractLongType(noUnpack) {\n  LongType.call(this);\n  this._noUnpack = !!noUnpack;\n}\nutil.inherits(AbstractLongType, LongType);\n\nAbstractLongType.prototype._check = function (val, cb) {\n  var b = this._isValid(val);\n  if (!b && cb) {\n    cb(PATH.slice(), val, this);\n  }\n  return b;\n};\n\nAbstractLongType.prototype._read = function (tap) {\n  var buf, pos;\n  if (this._noUnpack) {\n    pos = tap.pos;\n    tap.skipLong();\n    buf = tap.buf.slice(pos, tap.pos);\n  } else {\n    buf = tap.unpackLongBytes(tap);\n  }\n  if (tap.isValid()) {\n    return this._fromBuffer(buf);\n  }\n};\n\nAbstractLongType.prototype._write = function (tap, val) {\n  if (!this._isValid(val)) {\n    throwInvalidError(null, val, this);\n  }\n  var buf = this._toBuffer(val);\n  if (this._noUnpack) {\n    tap.writeFixed(buf);\n  } else {\n    tap.packLongBytes(buf);\n  }\n};\n\nAbstractLongType.prototype._copy = function (val, opts) {\n  switch (opts && opts.coerce) {\n    case 3: // To string.\n      return this._toJSON(val);\n    case 2: // From string.\n      return this._fromJSON(val);\n    default: // Normal copy.\n      // Slow but guarantees most consistent results. Faster alternatives would\n      // require assumptions on the long class used (e.g. immutability).\n      return this._fromJSON(JSON.parse(JSON.stringify(this._toJSON(val))));\n  }\n};\n\nAbstractLongType.prototype.random = function () {\n  return this._fromJSON(LongType.prototype.random());\n};\n\n// Methods to be implemented by the user.\nAbstractLongType.prototype._fromBuffer = utils.abstractFunction;\nAbstractLongType.prototype._toBuffer = utils.abstractFunction;\nAbstractLongType.prototype._fromJSON = utils.abstractFunction;\nAbstractLongType.prototype._toJSON = utils.abstractFunction;\nAbstractLongType.prototype._isValid = utils.abstractFunction;\nAbstractLongType.prototype.compare = utils.abstractFunction;\n\n/**\n * Field.\n *\n * @param attrs {Object} The field's schema.\n * @para opts {Object} Schema parsing options (the same as `Type`s').\n *\n */\nfunction Field(attrs, opts) {\n  var name = attrs.name;\n  if (typeof name != 'string' || !NAME_PATTERN.test(name)) {\n    throw new Error(f('invalid field name: %s', name));\n  }\n\n  this._name = name;\n  this._type = createType(attrs.type, opts);\n  this._aliases = attrs.aliases || [];\n\n  this._order = (function (order) {\n    switch (order) {\n      case 'ascending':\n        return 1;\n      case 'descending':\n        return -1;\n      case 'ignore':\n        return 0;\n      default:\n        throw new Error(f('invalid order: %j', order));\n    }\n  })(attrs.order === undefined ? 'ascending' : attrs.order);\n\n  var value = attrs['default'];\n  if (value !== undefined) {\n    // We need to convert defaults back to a valid format (unions are\n    // disallowed in default definitions, only the first type of each union is\n    // allowed instead).\n    // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html\n    var type = this._type;\n    var val = type._copy(value, {coerce: 2, wrap: 2});\n    // The clone call above will throw an error if the default is invalid.\n    if (type instanceof PrimitiveType && !(type instanceof BytesType)) {\n      // These are immutable.\n      this.getDefault = function () { return val; };\n    } else {\n      this.getDefault = function () { return type._copy(val); };\n    }\n  }\n}\n\nField.prototype.getAliases = function () { return this._aliases; };\n\nField.prototype.getDefault = function () {}; // Undefined default.\n\nField.prototype.getName = function () { return this._name; };\n\nField.prototype.getOrder = function () {\n  return ['descending', 'ignore', 'ascending'][this._order + 1];\n};\n\nField.prototype.getType = function () { return this._type; };\n\nField.prototype.inspect = function () { return f('<Field %j>', this._name); };\n\n/**\n * Resolver to read a writer's schema as a new schema.\n *\n * @param readerType {Type} The type to convert to.\n *\n */\nfunction Resolver(readerType) {\n  // Add all fields here so that all resolvers share the same hidden class.\n  this._readerType = readerType;\n  this._items = null;\n  this._read = null;\n  this._size = 0;\n  this._symbols = null;\n  this._values = null;\n}\n\nResolver.prototype.inspect = function () { return '<Resolver>'; };\n\n/**\n * Read a value from a tap.\n *\n * @param type {Type} The type to decode.\n * @param tap {Tap} The tap to read from. No checks are performed here.\n * @param resolver {Resolver} Optional resolver. It must match the input type.\n * @param lazy {Boolean} Skip trailing fields when using a resolver.\n *\n */\nfunction readValue(type, tap, resolver, lazy) {\n  if (resolver) {\n    if (resolver._readerType !== type) {\n      throw new Error('invalid resolver');\n    }\n    return resolver._read(tap, lazy);\n  } else {\n    return type._read(tap);\n  }\n}\n\n/**\n * Create default parsing options.\n *\n * @param attrs {Object} Schema to populate options with.\n * @param opts {Object} Base options.\n *\n */\nfunction getOpts(attrs, opts) {\n  if (attrs === null) {\n    // Let's be helpful for this common error.\n    throw new Error('invalid type: null (did you mean \"null\"?)');\n  }\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n  opts.namespace = attrs.namespace || opts.namespace;\n  opts.logicalTypes = opts.logicalTypes || {};\n  return opts;\n}\n\n/**\n * Resolve a schema's name and aliases.\n *\n * @param attrs {Object} True schema (can't be a string).\n * @param namespace {String} Optional parent namespace.\n * @param key {String} Key where the name should be looked up (defaults to\n * `name`).\n *\n */\nfunction resolveNames(attrs, namespace, key) {\n  namespace = attrs.namespace || namespace;\n  key = key || 'name';\n\n  var name = attrs[key];\n  if (!name) {\n    throw new Error(f('missing %s property in schema: %j', key, attrs));\n  }\n  return {\n    name: qualify(name),\n    aliases: attrs.aliases ? attrs.aliases.map(qualify) : []\n  };\n\n  function qualify(name) {\n    if (!~name.indexOf('.') && namespace) {\n      name = namespace + '.' + name;\n    }\n    var tail = unqualify(name);\n    if (isPrimitive(tail)) {\n      // Primitive types cannot be defined in any namespace.\n      throw new Error(f('cannot rename primitive type: %j', tail));\n    }\n    name.split('.').forEach(function (part) {\n      if (!NAME_PATTERN.test(part)) {\n        throw new Error(f('invalid name: %j', name));\n      }\n    });\n    return name;\n  }\n}\n\n/**\n * Remove namespace from a name.\n *\n * @param name {String} Full or short name.\n *\n */\nfunction unqualify(name) {\n  var parts = name.split('.');\n  return parts[parts.length - 1];\n}\n\n/**\n * Get all aliases for a type (including its name).\n *\n * @param obj {Type|Object} Typically a type or a field. Its aliases property\n * must exist and be an array.\n *\n */\nfunction getAliases(obj) {\n  var names = [obj._name];\n  var aliases = obj._aliases;\n  var i, l;\n  for (i = 0, l = aliases.length; i < l; i++) {\n    names.push(aliases[i]);\n  }\n  return names;\n}\n\n/**\n * Get a type's \"type\" (as a string, e.g. `'record'`, `'string'`).\n *\n * @param type {Type} Any type.\n *\n */\nfunction getTypeName(type) {\n  var obj = type.toJSON();\n  return typeof obj == 'string' ? obj : obj.type;\n}\n\n/**\n * Check whether a type's name is a primitive.\n *\n * @param name {String} Type name (e.g. `'string'`, `'array'`).\n *\n */\nfunction isPrimitive(name) {\n  var type = TYPES[name];\n  return type !== undefined && type.prototype instanceof PrimitiveType;\n}\n\n/**\n * Get the number of elements in an array block.\n *\n * @param tap {Tap} A tap positioned at the beginning of an array block.\n *\n */\nfunction readArraySize(tap) {\n  var n = tap.readLong();\n  if (n < 0) {\n    n = -n;\n    tap.skipLong(); // Skip size.\n  }\n  return n;\n}\n\n/**\n * Correctly stringify an object which contains types.\n *\n * @param obj {Object} The object to stringify. Typically, a type itself or an\n * object containing types. Any types inside will be expanded only once then\n * referenced by name.\n * @param noDeref {Boolean} Always reference types by name when possible,\n * rather than expand it the first time it is encountered.\n *\n */\nfunction stringify(obj, noDeref) {\n  // Since JS objects are unordered, this implementation (unfortunately)\n  // relies on engines returning properties in the same order that they are\n  // inserted in. This is not in the JS spec, but can be \"somewhat\" safely\n  // assumed (more here: https://stackoverflow.com/q/5525795/1062617).\n  return (function (registry) {\n    return JSON.stringify(obj, function (key, value) {\n      if (value instanceof Field) {\n        return {name: value._name, type: value._type};\n      } else if (value && value.name) {\n        var name = value.name;\n        if (noDeref || registry[name]) {\n          return name;\n        }\n        registry[name] = true;\n      }\n      return value;\n    });\n  })({});\n}\n\n/**\n * Check whether a long can be represented without precision loss.\n *\n * @param n {Number} The number.\n *\n * Two things to note:\n *\n * + We are not using the `Number` constants for compatibility with older\n *   browsers.\n * + We must remove one from each bound because of rounding errors.\n *\n */\nfunction isSafeLong(n) {\n  return n >= -9007199254740990 && n <= 9007199254740990;\n}\n\n/**\n * Throw a somewhat helpful error on invalid object.\n *\n * @param path {Array} Passed from hook, but unused (because empty where this\n * function is used, since we aren't keeping track of it for effiency).\n * @param val {...} The object to reject.\n * @param type {Type} The type to check against.\n *\n * This method is mostly used from `_write` to signal an invalid object for a\n * given type. Note that this provides less information than calling `isValid`\n * with a hook since the path is not propagated (for efficiency reasons).\n *\n */\nfunction throwInvalidError(path, val, type) {\n  throw new Error(f('invalid %s: %j', type, val));\n}\n\n\nmodule.exports = {\n  createType: createType,\n  resolveNames: resolveNames, // Protocols use the same name resolution logic.\n  stringify: stringify,\n  types: (function () {\n    // Export the base types along with all concrete implementations.\n    var obj = {Type: Type, LogicalType: LogicalType};\n    var types = Object.keys(TYPES);\n    var i, l, Class;\n    for (i = 0, l = types.length; i < l; i++) {\n      Class = TYPES[types[i]];\n      obj[Class.name] = Class;\n    }\n    return obj;\n  })()\n};\n","/* jshint node: true */\n\n/**\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *  https://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\n'use strict';\n\nvar crypto = require('crypto');\n\n\n/**\n * Uppercase the first letter of a string.\n *\n * @param s {String} The string.\n *\n */\nfunction capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\n\n/**\n * Compare two numbers.\n *\n * @param n1 {Number} The first one.\n * @param n2 {Number} The second one.\n *\n */\nfunction compare(n1, n2) { return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1); }\n\n/**\n * Compute a string's hash.\n *\n * @param str {String} The string to hash.\n * @param algorithm {String} The algorithm used. Defaults to MD5.\n *\n */\nfunction getHash(str, algorithm) {\n  algorithm = algorithm || 'md5';\n  var hash = crypto.createHash(algorithm);\n  hash.end(str);\n  return hash.read();\n}\n\n/**\n * Find index of value in array.\n *\n * @param arr {Array} Can also be a false-ish value.\n * @param v {Object} Value to find.\n *\n * Returns -1 if not found, -2 if found multiple times.\n *\n */\nfunction singleIndexOf(arr, v) {\n  var pos = -1;\n  var i, l;\n  if (!arr) {\n    return -1;\n  }\n  for (i = 0, l = arr.length; i < l; i++) {\n    if (arr[i] === v) {\n      if (pos >= 0) {\n        return -2;\n      }\n      pos = i;\n    }\n  }\n  return pos;\n}\n\n/**\n * Convert array to map.\n *\n * @param arr {Array} Elements.\n * @param fn {Function} Function returning an element's key.\n *\n */\nfunction toMap(arr, fn) {\n  var obj = {};\n  var i, elem;\n  for (i = 0; i < arr.length; i++) {\n    elem = arr[i];\n    obj[fn(elem)] = elem;\n  }\n  return obj;\n}\n\n/**\n * Check whether an array has duplicates.\n *\n * @param arr {Array} The array.\n * @param fn {Function} Optional function to apply to each element.\n *\n */\nfunction hasDuplicates(arr, fn) {\n  var obj = {};\n  var i, l, elem;\n  for (i = 0, l = arr.length; i < l; i++) {\n    elem = arr[i];\n    if (fn) {\n      elem = fn(elem);\n    }\n    if (obj[elem]) {\n      return true;\n    }\n    obj[elem] = true;\n  }\n  return false;\n}\n\n/**\n * \"Abstract\" function to help with \"subclassing\".\n *\n */\nfunction abstractFunction() { throw new Error('abstract'); }\n\n/**\n * Generator of random things.\n *\n * Inspired by: https://stackoverflow.com/a/424445/1062617\n *\n */\nfunction Lcg(seed) {\n  var a = 1103515245;\n  var c = 12345;\n  var m = Math.pow(2, 31);\n  var state = Math.floor(seed || Math.random() * (m - 1));\n\n  this._max = m;\n  this._nextInt = function () {\n    state = (a * state + c) % m;\n    return state;\n  };\n}\n\nLcg.prototype.nextBoolean = function () {\n  // jshint -W018\n  return !!(this._nextInt() % 2);\n};\n\nLcg.prototype.nextInt = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? this._max : end;\n  return start + Math.floor(this.nextFloat() * (end - start));\n};\n\nLcg.prototype.nextFloat = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? 1 : end;\n  return start + (end - start) * this._nextInt() / this._max;\n};\n\nLcg.prototype.nextString = function(len, flags) {\n  len |= 0;\n  flags = flags || 'aA';\n  var mask = '';\n  if (flags.indexOf('a') > -1) {\n    mask += 'abcdefghijklmnopqrstuvwxyz';\n  }\n  if (flags.indexOf('A') > -1) {\n    mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  }\n  if (flags.indexOf('#') > -1) {\n    mask += '0123456789';\n  }\n  if (flags.indexOf('!') > -1) {\n    mask += '~`!@#$%^&*()_+-={}[]:\";\\'<>?,./|\\\\';\n  }\n  var result = [];\n  for (var i = 0; i < len; i++) {\n    result.push(this.choice(mask));\n  }\n  return result.join('');\n};\n\nLcg.prototype.nextBuffer = function (len) {\n  var arr = [];\n  var i;\n  for (i = 0; i < len; i++) {\n    arr.push(this.nextInt(256));\n  }\n  return Buffer.from(arr);\n};\n\nLcg.prototype.choice = function (arr) {\n  var len = arr.length;\n  if (!len) {\n    throw new Error('choosing from empty array');\n  }\n  return arr[this.nextInt(len)];\n};\n\n/**\n * Ordered queue which returns items consecutively.\n *\n * This is actually a heap by index, with the added requirements that elements\n * can only be retrieved consecutively.\n *\n */\nfunction OrderedQueue() {\n  this._index = 0;\n  this._items = [];\n}\n\nOrderedQueue.prototype.push = function (item) {\n  var items = this._items;\n  var i = items.length | 0;\n  var j;\n  items.push(item);\n  while (i > 0 && items[i].index < items[j = ((i - 1) >> 1)].index) {\n    item = items[i];\n    items[i] = items[j];\n    items[j] = item;\n    i = j;\n  }\n};\n\nOrderedQueue.prototype.pop = function () {\n  var items = this._items;\n  var len = (items.length - 1) | 0;\n  var first = items[0];\n  if (!first || first.index > this._index) {\n    return null;\n  }\n  this._index++;\n  if (!len) {\n    items.pop();\n    return first;\n  }\n  items[0] = items.pop();\n  var mid = len >> 1;\n  var i = 0;\n  var i1, i2, j, item, c, c1, c2;\n  while (i < mid) {\n    item = items[i];\n    i1 = (i << 1) + 1;\n    i2 = (i + 1) << 1;\n    c1 = items[i1];\n    c2 = items[i2];\n    if (!c2 || c1.index <= c2.index) {\n      c = c1;\n      j = i1;\n    } else {\n      c = c2;\n      j = i2;\n    }\n    if (c.index >= item.index) {\n      break;\n    }\n    items[j] = item;\n    items[i] = c;\n    i = j;\n  }\n  return first;\n};\n\n/**\n * A tap is a buffer which remembers what has been already read.\n *\n * It is optimized for performance, at the cost of failing silently when\n * overflowing the buffer. This is a purposeful trade-off given the expected\n * rarity of this case and the large performance hit necessary to enforce\n * validity. See `isValid` below for more information.\n *\n */\nfunction Tap(buf, pos) {\n  this.buf = buf;\n  this.pos = pos | 0;\n}\n\n/**\n * Check that the tap is in a valid state.\n *\n * For efficiency reasons, none of the methods below will fail if an overflow\n * occurs (either read, skip, or write). For this reason, it is up to the\n * caller to always check that the read, skip, or write was valid by calling\n * this method.\n *\n */\nTap.prototype.isValid = function () { return this.pos <= this.buf.length; };\n\n/**\n * Returns the contents of the tap up to the current position.\n *\n */\nTap.prototype.getValue = function () { return this.buf.slice(0, this.pos); };\n\n// Read, skip, write methods.\n//\n// These should fail silently when the buffer overflows. Note this is only\n// required to be true when the functions are decoding valid objects. For\n// example errors will still be thrown if a bad count is read, leading to a\n// negative position offset (which will typically cause a failure in\n// `readFixed`).\n\nTap.prototype.readBoolean = function () { return !!this.buf[this.pos++]; };\n\nTap.prototype.skipBoolean = function () { this.pos++; };\n\nTap.prototype.writeBoolean = function (b) { this.buf[this.pos++] = !!b; };\n\nTap.prototype.readInt = Tap.prototype.readLong = function () {\n  var n = 0;\n  var k = 0;\n  var buf = this.buf;\n  var b, h, f, fk;\n\n  do {\n    b = buf[this.pos++];\n    h = b & 0x80;\n    n |= (b & 0x7f) << k;\n    k += 7;\n  } while (h && k < 28);\n\n  if (h) {\n    // Switch to float arithmetic, otherwise we might overflow.\n    f = n;\n    fk = 268435456; // 2 ** 28.\n    do {\n      b = buf[this.pos++];\n      f += (b & 0x7f) * fk;\n      fk *= 128;\n    } while (b & 0x80);\n    return (f % 2 ? -(f + 1) : f) / 2;\n  }\n\n  return (n >> 1) ^ -(n & 1);\n};\n\nTap.prototype.skipInt = Tap.prototype.skipLong = function () {\n  var buf = this.buf;\n  while (buf[this.pos++] & 0x80) {}\n};\n\nTap.prototype.writeInt = Tap.prototype.writeLong = function (n) {\n  var buf = this.buf;\n  var f, m;\n\n  if (n >= -1073741824 && n < 1073741824) {\n    // Won't overflow, we can use integer arithmetic.\n    m = n >= 0 ? n << 1 : (~n << 1) | 1;\n    do {\n      buf[this.pos] = m & 0x7f;\n      m >>= 7;\n    } while (m && (buf[this.pos++] |= 0x80));\n  } else {\n    // We have to use slower floating arithmetic.\n    f = n >= 0 ? n * 2 : (-n * 2) - 1;\n    do {\n      buf[this.pos] = f & 0x7f;\n      f /= 128;\n    } while (f >= 1 && (buf[this.pos++] |= 0x80));\n  }\n  this.pos++;\n};\n\nTap.prototype.readFloat = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.readFloatLE(pos);\n};\n\nTap.prototype.skipFloat = function () { this.pos += 4; };\n\nTap.prototype.writeFloat = function (f) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeFloatLE(f, pos);\n};\n\nTap.prototype.readDouble = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.readDoubleLE(pos);\n};\n\nTap.prototype.skipDouble = function () { this.pos += 8; };\n\nTap.prototype.writeDouble = function (d) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeDoubleLE(d, pos);\n};\n\nTap.prototype.readFixed = function (len) {\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  var fixed = Buffer.alloc(len);\n  this.buf.copy(fixed, 0, pos, pos + len);\n  return fixed;\n};\n\nTap.prototype.skipFixed = function (len) { this.pos += len; };\n\nTap.prototype.writeFixed = function (buf, len) {\n  len = len || buf.length;\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  buf.copy(this.buf, pos, 0, len);\n};\n\nTap.prototype.readBytes = function () {\n  return this.readFixed(this.readLong());\n};\n\nTap.prototype.skipBytes = function () {\n  var len = this.readLong();\n  this.pos += len;\n};\n\nTap.prototype.writeBytes = function (buf) {\n  var len = buf.length;\n  this.writeLong(len);\n  this.writeFixed(buf, len);\n};\n\nTap.prototype.readString = function () {\n  var len = this.readLong();\n  var pos = this.pos;\n  var buf = this.buf;\n  this.pos += len;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.utf8Slice(pos, pos + len);\n};\n\nTap.prototype.skipString = function () {\n  var len = this.readLong();\n  this.pos += len;\n};\n\nTap.prototype.writeString = function (s) {\n  var len = Buffer.byteLength(s);\n  this.writeLong(len);\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  this.buf.utf8Write(s, pos, len);\n};\n\n// Helper used to speed up writing defaults.\n\nTap.prototype.writeBinary = function (str, len) {\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  this.buf.write(str, pos, len, 'binary');\n};\n\n// Binary comparison methods.\n//\n// These are not guaranteed to consume the objects they are comparing when\n// returning a non-zero result (allowing for performance benefits), so no other\n// operations should be done on either tap after a compare returns a non-zero\n// value. Also, these methods do not have the same silent failure requirement\n// as read, skip, and write since they are assumed to be called on valid\n// buffers.\n\nTap.prototype.matchBoolean = function (tap) {\n  return this.buf[this.pos++] - tap.buf[tap.pos++];\n};\n\nTap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {\n  var n1 = this.readLong();\n  var n2 = tap.readLong();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchFloat = function (tap) {\n  var n1 = this.readFloat();\n  var n2 = tap.readFloat();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchDouble = function (tap) {\n  var n1 = this.readDouble();\n  var n2 = tap.readDouble();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchFixed = function (tap, len) {\n  return this.readFixed(len).compare(tap.readFixed(len));\n};\n\nTap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {\n  var l1 = this.readLong();\n  var p1 = this.pos;\n  this.pos += l1;\n  var l2 = tap.readLong();\n  var p2 = tap.pos;\n  tap.pos += l2;\n  var b1 = this.buf.slice(p1, this.pos);\n  var b2 = tap.buf.slice(p2, tap.pos);\n  return b1.compare(b2);\n};\n\n// Functions for supporting custom long classes.\n//\n// The two following methods allow the long implementations to not have to\n// worry about Avro's zigzag encoding, we directly expose longs as unpacked.\n\nTap.prototype.unpackLongBytes = function () {\n  var res = Buffer.alloc(8);\n  var n = 0;\n  var i = 0; // Byte index in target buffer.\n  var j = 6; // Bit offset in current target buffer byte.\n  var buf = this.buf;\n  var b, neg;\n\n  b = buf[this.pos++];\n  neg = b & 1;\n  res.fill(0);\n\n  n |= (b & 0x7f) >> 1;\n  while (b & 0x80) {\n    b = buf[this.pos++];\n    n |= (b & 0x7f) << j;\n    j += 7;\n    if (j >= 8) {\n      // Flush byte.\n      j -= 8;\n      res[i++] = n;\n      n >>= 8;\n    }\n  }\n  res[i] = n;\n\n  if (neg) {\n    invert(res, 8);\n  }\n\n  return res;\n};\n\nTap.prototype.packLongBytes = function (buf) {\n  var neg = (buf[7] & 0x80) >> 7;\n  var res = this.buf;\n  var j = 1;\n  var k = 0;\n  var m = 3;\n  var n;\n\n  if (neg) {\n    invert(buf, 8);\n    n = 1;\n  } else {\n    n = 0;\n  }\n\n  var parts = [\n    buf.readUIntLE(0, 3),\n    buf.readUIntLE(3, 3),\n    buf.readUIntLE(6, 2)\n  ];\n  // Not reading more than 24 bits because we need to be able to combine the\n  // \"carry\" bits from the previous part and JavaScript only supports bitwise\n  // operations on 32 bit integers.\n  while (m && !parts[--m]) {} // Skip trailing 0s.\n\n  // Leading parts (if any), we never bail early here since we need the\n  // continuation bit to be set.\n  while (k < m) {\n    n |= parts[k++] << j;\n    j += 24;\n    while (j > 7) {\n      res[this.pos++] = (n & 0x7f) | 0x80;\n      n >>= 7;\n      j -= 7;\n    }\n  }\n\n  // Final part, similar to normal packing aside from the initial offset.\n  n |= parts[m] << j;\n  do {\n    res[this.pos] = n & 0x7f;\n    n >>= 7;\n  } while (n && (res[this.pos++] |= 0x80));\n  this.pos++;\n\n  // Restore original buffer (could make this optional?).\n  if (neg) {\n    invert(buf, 8);\n  }\n};\n\n// Helpers.\n\n/**\n * Invert all bits in a buffer.\n *\n * @param buf {Buffer} Non-empty buffer to invert.\n * @param len {Number} Buffer length (must be positive).\n *\n */\nfunction invert(buf, len) {\n  while (len--) {\n    buf[len] = ~buf[len];\n  }\n}\n\n\nmodule.exports = {\n  abstractFunction: abstractFunction,\n  capitalize: capitalize,\n  compare: compare,\n  getHash: getHash,\n  toMap: toMap,\n  singleIndexOf: singleIndexOf,\n  hasDuplicates: hasDuplicates,\n  Lcg: Lcg,\n  OrderedQueue: OrderedQueue,\n  Tap: Tap\n};\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function () {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function () {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function () {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function () {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function () {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _version.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('md5').update(bytes).digest();\n}\n\nvar _default = md5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\n\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    _crypto.default.randomFillSync(rnds8Pool);\n\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('sha1').update(bytes).digest();\n}\n\nvar _default = sha1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.default)(b);\n}\n\nvar _default = v1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.default)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.default)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nvar _default = version;\nexports.default = _default;","module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"tls\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","//     Underscore.js 1.13.6\n//     https://underscorejs.org\n//     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// Current version.\nvar VERSION = '1.13.6';\n\n// Establish the root object, `window` (`self`) in the browser, `global`\n// on the server, or `this` in some virtual machines. We use `self`\n// instead of `window` for `WebWorker` support.\nvar root = (typeof self == 'object' && self.self === self && self) ||\n          (typeof global == 'object' && global.global === global && global) ||\n          Function('return this')() ||\n          {};\n\n// Save bytes in the minified (but not gzipped) version:\nvar ArrayProto = Array.prototype, ObjProto = Object.prototype;\nvar SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n// Create quick reference variables for speed access to core prototypes.\nvar push = ArrayProto.push,\n    slice = ArrayProto.slice,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty;\n\n// Modern feature detection.\nvar supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',\n    supportsDataView = typeof DataView !== 'undefined';\n\n// All **ECMAScript 5+** native function implementations that we hope to use\n// are declared here.\nvar nativeIsArray = Array.isArray,\n    nativeKeys = Object.keys,\n    nativeCreate = Object.create,\n    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;\n\n// Create references to these builtin functions because we override them.\nvar _isNaN = isNaN,\n    _isFinite = isFinite;\n\n// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\nvar hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\nvar nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n  'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n// The largest integer that can be represented exactly.\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n// Some functions take a variable number of arguments, or a few expected\n// arguments at the beginning and then a variable number of values to operate\n// on. This helper accumulates all remaining arguments past the function’s\n// argument length (or an explicit `startIndex`), into an array that becomes\n// the last argument. Similar to ES6’s \"rest parameter\".\nfunction restArguments(func, startIndex) {\n  startIndex = startIndex == null ? func.length - 1 : +startIndex;\n  return function() {\n    var length = Math.max(arguments.length - startIndex, 0),\n        rest = Array(length),\n        index = 0;\n    for (; index < length; index++) {\n      rest[index] = arguments[index + startIndex];\n    }\n    switch (startIndex) {\n      case 0: return func.call(this, rest);\n      case 1: return func.call(this, arguments[0], rest);\n      case 2: return func.call(this, arguments[0], arguments[1], rest);\n    }\n    var args = Array(startIndex + 1);\n    for (index = 0; index < startIndex; index++) {\n      args[index] = arguments[index];\n    }\n    args[startIndex] = rest;\n    return func.apply(this, args);\n  };\n}\n\n// Is a given variable an object?\nfunction isObject(obj) {\n  var type = typeof obj;\n  return type === 'function' || (type === 'object' && !!obj);\n}\n\n// Is a given value equal to null?\nfunction isNull(obj) {\n  return obj === null;\n}\n\n// Is a given variable undefined?\nfunction isUndefined(obj) {\n  return obj === void 0;\n}\n\n// Is a given value a boolean?\nfunction isBoolean(obj) {\n  return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n}\n\n// Is a given value a DOM element?\nfunction isElement(obj) {\n  return !!(obj && obj.nodeType === 1);\n}\n\n// Internal function for creating a `toString`-based type tester.\nfunction tagTester(name) {\n  var tag = '[object ' + name + ']';\n  return function(obj) {\n    return toString.call(obj) === tag;\n  };\n}\n\nvar isString = tagTester('String');\n\nvar isNumber = tagTester('Number');\n\nvar isDate = tagTester('Date');\n\nvar isRegExp = tagTester('RegExp');\n\nvar isError = tagTester('Error');\n\nvar isSymbol = tagTester('Symbol');\n\nvar isArrayBuffer = tagTester('ArrayBuffer');\n\nvar isFunction = tagTester('Function');\n\n// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old\n// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\nvar nodelist = root.document && root.document.childNodes;\nif (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n  isFunction = function(obj) {\n    return typeof obj == 'function' || false;\n  };\n}\n\nvar isFunction$1 = isFunction;\n\nvar hasObjectTag = tagTester('Object');\n\n// In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.\n// In IE 11, the most common among them, this problem also applies to\n// `Map`, `WeakMap` and `Set`.\nvar hasStringTagBug = (\n      supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8)))\n    ),\n    isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));\n\nvar isDataView = tagTester('DataView');\n\n// In IE 10 - Edge 13, we need a different heuristic\n// to determine whether an object is a `DataView`.\nfunction ie10IsDataView(obj) {\n  return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);\n}\n\nvar isDataView$1 = (hasStringTagBug ? ie10IsDataView : isDataView);\n\n// Is a given value an array?\n// Delegates to ECMA5's native `Array.isArray`.\nvar isArray = nativeIsArray || tagTester('Array');\n\n// Internal function to check whether `key` is an own property name of `obj`.\nfunction has$1(obj, key) {\n  return obj != null && hasOwnProperty.call(obj, key);\n}\n\nvar isArguments = tagTester('Arguments');\n\n// Define a fallback version of the method in browsers (ahem, IE < 9), where\n// there isn't any inspectable \"Arguments\" type.\n(function() {\n  if (!isArguments(arguments)) {\n    isArguments = function(obj) {\n      return has$1(obj, 'callee');\n    };\n  }\n}());\n\nvar isArguments$1 = isArguments;\n\n// Is a given object a finite number?\nfunction isFinite$1(obj) {\n  return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));\n}\n\n// Is the given value `NaN`?\nfunction isNaN$1(obj) {\n  return isNumber(obj) && _isNaN(obj);\n}\n\n// Predicate-generating function. Often useful outside of Underscore.\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n// Common internal logic for `isArrayLike` and `isBufferLike`.\nfunction createSizePropertyCheck(getSizeProperty) {\n  return function(collection) {\n    var sizeProperty = getSizeProperty(collection);\n    return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;\n  }\n}\n\n// Internal helper to generate a function to obtain property `key` from `obj`.\nfunction shallowProperty(key) {\n  return function(obj) {\n    return obj == null ? void 0 : obj[key];\n  };\n}\n\n// Internal helper to obtain the `byteLength` property of an object.\nvar getByteLength = shallowProperty('byteLength');\n\n// Internal helper to determine whether we should spend extensive checks against\n// `ArrayBuffer` et al.\nvar isBufferLike = createSizePropertyCheck(getByteLength);\n\n// Is a given value a typed array?\nvar typedArrayPattern = /\\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\\]/;\nfunction isTypedArray(obj) {\n  // `ArrayBuffer.isView` is the most future-proof, so use it when available.\n  // Otherwise, fall back on the above regular expression.\n  return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :\n                isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));\n}\n\nvar isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);\n\n// Internal helper to obtain the `length` property of an object.\nvar getLength = shallowProperty('length');\n\n// Internal helper to create a simple lookup structure.\n// `collectNonEnumProps` used to depend on `_.contains`, but this led to\n// circular imports. `emulatedSet` is a one-off solution that only works for\n// arrays of strings.\nfunction emulatedSet(keys) {\n  var hash = {};\n  for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;\n  return {\n    contains: function(key) { return hash[key] === true; },\n    push: function(key) {\n      hash[key] = true;\n      return keys.push(key);\n    }\n  };\n}\n\n// Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't\n// be iterated by `for key in ...` and thus missed. Extends `keys` in place if\n// needed.\nfunction collectNonEnumProps(obj, keys) {\n  keys = emulatedSet(keys);\n  var nonEnumIdx = nonEnumerableProps.length;\n  var constructor = obj.constructor;\n  var proto = (isFunction$1(constructor) && constructor.prototype) || ObjProto;\n\n  // Constructor is a special case.\n  var prop = 'constructor';\n  if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);\n\n  while (nonEnumIdx--) {\n    prop = nonEnumerableProps[nonEnumIdx];\n    if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {\n      keys.push(prop);\n    }\n  }\n}\n\n// Retrieve the names of an object's own properties.\n// Delegates to **ECMAScript 5**'s native `Object.keys`.\nfunction keys(obj) {\n  if (!isObject(obj)) return [];\n  if (nativeKeys) return nativeKeys(obj);\n  var keys = [];\n  for (var key in obj) if (has$1(obj, key)) keys.push(key);\n  // Ahem, IE < 9.\n  if (hasEnumBug) collectNonEnumProps(obj, keys);\n  return keys;\n}\n\n// Is a given array, string, or object empty?\n// An \"empty\" object has no enumerable own-properties.\nfunction isEmpty(obj) {\n  if (obj == null) return true;\n  // Skip the more expensive `toString`-based type checks if `obj` has no\n  // `.length`.\n  var length = getLength(obj);\n  if (typeof length == 'number' && (\n    isArray(obj) || isString(obj) || isArguments$1(obj)\n  )) return length === 0;\n  return getLength(keys(obj)) === 0;\n}\n\n// Returns whether an object has a given set of `key:value` pairs.\nfunction isMatch(object, attrs) {\n  var _keys = keys(attrs), length = _keys.length;\n  if (object == null) return !length;\n  var obj = Object(object);\n  for (var i = 0; i < length; i++) {\n    var key = _keys[i];\n    if (attrs[key] !== obj[key] || !(key in obj)) return false;\n  }\n  return true;\n}\n\n// If Underscore is called as a function, it returns a wrapped object that can\n// be used OO-style. This wrapper holds altered versions of all functions added\n// through `_.mixin`. Wrapped objects may be chained.\nfunction _$1(obj) {\n  if (obj instanceof _$1) return obj;\n  if (!(this instanceof _$1)) return new _$1(obj);\n  this._wrapped = obj;\n}\n\n_$1.VERSION = VERSION;\n\n// Extracts the result from a wrapped and chained object.\n_$1.prototype.value = function() {\n  return this._wrapped;\n};\n\n// Provide unwrapping proxies for some methods used in engine operations\n// such as arithmetic and JSON stringification.\n_$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;\n\n_$1.prototype.toString = function() {\n  return String(this._wrapped);\n};\n\n// Internal function to wrap or shallow-copy an ArrayBuffer,\n// typed array or DataView to a new view, reusing the buffer.\nfunction toBufferView(bufferSource) {\n  return new Uint8Array(\n    bufferSource.buffer || bufferSource,\n    bufferSource.byteOffset || 0,\n    getByteLength(bufferSource)\n  );\n}\n\n// We use this string twice, so give it a name for minification.\nvar tagDataView = '[object DataView]';\n\n// Internal recursive comparison function for `_.isEqual`.\nfunction eq(a, b, aStack, bStack) {\n  // Identical objects are equal. `0 === -0`, but they aren't identical.\n  // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).\n  if (a === b) return a !== 0 || 1 / a === 1 / b;\n  // `null` or `undefined` only equal to itself (strict comparison).\n  if (a == null || b == null) return false;\n  // `NaN`s are equivalent, but non-reflexive.\n  if (a !== a) return b !== b;\n  // Exhaust primitive checks\n  var type = typeof a;\n  if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n  return deepEq(a, b, aStack, bStack);\n}\n\n// Internal recursive comparison function for `_.isEqual`.\nfunction deepEq(a, b, aStack, bStack) {\n  // Unwrap any wrapped objects.\n  if (a instanceof _$1) a = a._wrapped;\n  if (b instanceof _$1) b = b._wrapped;\n  // Compare `[[Class]]` names.\n  var className = toString.call(a);\n  if (className !== toString.call(b)) return false;\n  // Work around a bug in IE 10 - Edge 13.\n  if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {\n    if (!isDataView$1(b)) return false;\n    className = tagDataView;\n  }\n  switch (className) {\n    // These types are compared by value.\n    case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n    case '[object String]':\n      // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n      // equivalent to `new String(\"5\")`.\n      return '' + a === '' + b;\n    case '[object Number]':\n      // `NaN`s are equivalent, but non-reflexive.\n      // Object(NaN) is equivalent to NaN.\n      if (+a !== +a) return +b !== +b;\n      // An `egal` comparison is performed for other numeric values.\n      return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n    case '[object Date]':\n    case '[object Boolean]':\n      // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n      // millisecond representations. Note that invalid dates with millisecond representations\n      // of `NaN` are not equivalent.\n      return +a === +b;\n    case '[object Symbol]':\n      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n    case '[object ArrayBuffer]':\n    case tagDataView:\n      // Coerce to typed array so we can fall through.\n      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);\n  }\n\n  var areArrays = className === '[object Array]';\n  if (!areArrays && isTypedArray$1(a)) {\n      var byteLength = getByteLength(a);\n      if (byteLength !== getByteLength(b)) return false;\n      if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;\n      areArrays = true;\n  }\n  if (!areArrays) {\n    if (typeof a != 'object' || typeof b != 'object') return false;\n\n    // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor &&\n                             isFunction$1(bCtor) && bCtor instanceof bCtor)\n                        && ('constructor' in a && 'constructor' in b)) {\n      return false;\n    }\n  }\n  // Assume equality for cyclic structures. The algorithm for detecting cyclic\n  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n  // Initializing stack of traversed objects.\n  // It's done here since we only need them for objects and arrays comparison.\n  aStack = aStack || [];\n  bStack = bStack || [];\n  var length = aStack.length;\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    if (aStack[length] === a) return bStack[length] === b;\n  }\n\n  // Add the first object to the stack of traversed objects.\n  aStack.push(a);\n  bStack.push(b);\n\n  // Recursively compare objects and arrays.\n  if (areArrays) {\n    // Compare array lengths to determine if a deep comparison is necessary.\n    length = a.length;\n    if (length !== b.length) return false;\n    // Deep compare the contents, ignoring non-numeric properties.\n    while (length--) {\n      if (!eq(a[length], b[length], aStack, bStack)) return false;\n    }\n  } else {\n    // Deep compare objects.\n    var _keys = keys(a), key;\n    length = _keys.length;\n    // Ensure that both objects contain the same number of properties before comparing deep equality.\n    if (keys(b).length !== length) return false;\n    while (length--) {\n      // Deep compare each member\n      key = _keys[length];\n      if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n    }\n  }\n  // Remove the first object from the stack of traversed objects.\n  aStack.pop();\n  bStack.pop();\n  return true;\n}\n\n// Perform a deep comparison to check if two objects are equal.\nfunction isEqual(a, b) {\n  return eq(a, b);\n}\n\n// Retrieve all the enumerable property names of an object.\nfunction allKeys(obj) {\n  if (!isObject(obj)) return [];\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  // Ahem, IE < 9.\n  if (hasEnumBug) collectNonEnumProps(obj, keys);\n  return keys;\n}\n\n// Since the regular `Object.prototype.toString` type tests don't work for\n// some types in IE 11, we use a fingerprinting heuristic instead, based\n// on the methods. It's not great, but it's the best we got.\n// The fingerprint method lists are defined below.\nfunction ie11fingerprint(methods) {\n  var length = getLength(methods);\n  return function(obj) {\n    if (obj == null) return false;\n    // `Map`, `WeakMap` and `Set` have no enumerable keys.\n    var keys = allKeys(obj);\n    if (getLength(keys)) return false;\n    for (var i = 0; i < length; i++) {\n      if (!isFunction$1(obj[methods[i]])) return false;\n    }\n    // If we are testing against `WeakMap`, we need to ensure that\n    // `obj` doesn't have a `forEach` method in order to distinguish\n    // it from a regular `Map`.\n    return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);\n  };\n}\n\n// In the interest of compact minification, we write\n// each string in the fingerprints only once.\nvar forEachName = 'forEach',\n    hasName = 'has',\n    commonInit = ['clear', 'delete'],\n    mapTail = ['get', hasName, 'set'];\n\n// `Map`, `WeakMap` and `Set` each have slightly different\n// combinations of the above sublists.\nvar mapMethods = commonInit.concat(forEachName, mapTail),\n    weakMapMethods = commonInit.concat(mapTail),\n    setMethods = ['add'].concat(commonInit, forEachName, hasName);\n\nvar isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');\n\nvar isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');\n\nvar isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');\n\nvar isWeakSet = tagTester('WeakSet');\n\n// Retrieve the values of an object's properties.\nfunction values(obj) {\n  var _keys = keys(obj);\n  var length = _keys.length;\n  var values = Array(length);\n  for (var i = 0; i < length; i++) {\n    values[i] = obj[_keys[i]];\n  }\n  return values;\n}\n\n// Convert an object into a list of `[key, value]` pairs.\n// The opposite of `_.object` with one argument.\nfunction pairs(obj) {\n  var _keys = keys(obj);\n  var length = _keys.length;\n  var pairs = Array(length);\n  for (var i = 0; i < length; i++) {\n    pairs[i] = [_keys[i], obj[_keys[i]]];\n  }\n  return pairs;\n}\n\n// Invert the keys and values of an object. The values must be serializable.\nfunction invert(obj) {\n  var result = {};\n  var _keys = keys(obj);\n  for (var i = 0, length = _keys.length; i < length; i++) {\n    result[obj[_keys[i]]] = _keys[i];\n  }\n  return result;\n}\n\n// Return a sorted list of the function names available on the object.\nfunction functions(obj) {\n  var names = [];\n  for (var key in obj) {\n    if (isFunction$1(obj[key])) names.push(key);\n  }\n  return names.sort();\n}\n\n// An internal function for creating assigner functions.\nfunction createAssigner(keysFunc, defaults) {\n  return function(obj) {\n    var length = arguments.length;\n    if (defaults) obj = Object(obj);\n    if (length < 2 || obj == null) return obj;\n    for (var index = 1; index < length; index++) {\n      var source = arguments[index],\n          keys = keysFunc(source),\n          l = keys.length;\n      for (var i = 0; i < l; i++) {\n        var key = keys[i];\n        if (!defaults || obj[key] === void 0) obj[key] = source[key];\n      }\n    }\n    return obj;\n  };\n}\n\n// Extend a given object with all the properties in passed-in object(s).\nvar extend = createAssigner(allKeys);\n\n// Assigns a given object with all the own properties in the passed-in\n// object(s).\n// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\nvar extendOwn = createAssigner(keys);\n\n// Fill in a given object with default properties.\nvar defaults = createAssigner(allKeys, true);\n\n// Create a naked function reference for surrogate-prototype-swapping.\nfunction ctor() {\n  return function(){};\n}\n\n// An internal function for creating a new object that inherits from another.\nfunction baseCreate(prototype) {\n  if (!isObject(prototype)) return {};\n  if (nativeCreate) return nativeCreate(prototype);\n  var Ctor = ctor();\n  Ctor.prototype = prototype;\n  var result = new Ctor;\n  Ctor.prototype = null;\n  return result;\n}\n\n// Creates an object that inherits from the given prototype object.\n// If additional properties are provided then they will be added to the\n// created object.\nfunction create(prototype, props) {\n  var result = baseCreate(prototype);\n  if (props) extendOwn(result, props);\n  return result;\n}\n\n// Create a (shallow-cloned) duplicate of an object.\nfunction clone(obj) {\n  if (!isObject(obj)) return obj;\n  return isArray(obj) ? obj.slice() : extend({}, obj);\n}\n\n// Invokes `interceptor` with the `obj` and then returns `obj`.\n// The primary purpose of this method is to \"tap into\" a method chain, in\n// order to perform operations on intermediate results within the chain.\nfunction tap(obj, interceptor) {\n  interceptor(obj);\n  return obj;\n}\n\n// Normalize a (deep) property `path` to array.\n// Like `_.iteratee`, this function can be customized.\nfunction toPath$1(path) {\n  return isArray(path) ? path : [path];\n}\n_$1.toPath = toPath$1;\n\n// Internal wrapper for `_.toPath` to enable minification.\n// Similar to `cb` for `_.iteratee`.\nfunction toPath(path) {\n  return _$1.toPath(path);\n}\n\n// Internal function to obtain a nested property in `obj` along `path`.\nfunction deepGet(obj, path) {\n  var length = path.length;\n  for (var i = 0; i < length; i++) {\n    if (obj == null) return void 0;\n    obj = obj[path[i]];\n  }\n  return length ? obj : void 0;\n}\n\n// Get the value of the (deep) property on `path` from `object`.\n// If any property in `path` does not exist or if the value is\n// `undefined`, return `defaultValue` instead.\n// The `path` is normalized through `_.toPath`.\nfunction get(object, path, defaultValue) {\n  var value = deepGet(object, toPath(path));\n  return isUndefined(value) ? defaultValue : value;\n}\n\n// Shortcut function for checking if an object has a given property directly on\n// itself (in other words, not on a prototype). Unlike the internal `has`\n// function, this public version can also traverse nested properties.\nfunction has(obj, path) {\n  path = toPath(path);\n  var length = path.length;\n  for (var i = 0; i < length; i++) {\n    var key = path[i];\n    if (!has$1(obj, key)) return false;\n    obj = obj[key];\n  }\n  return !!length;\n}\n\n// Keep the identity function around for default iteratees.\nfunction identity(value) {\n  return value;\n}\n\n// Returns a predicate for checking whether an object has a given set of\n// `key:value` pairs.\nfunction matcher(attrs) {\n  attrs = extendOwn({}, attrs);\n  return function(obj) {\n    return isMatch(obj, attrs);\n  };\n}\n\n// Creates a function that, when passed an object, will traverse that object’s\n// properties down the given `path`, specified as an array of keys or indices.\nfunction property(path) {\n  path = toPath(path);\n  return function(obj) {\n    return deepGet(obj, path);\n  };\n}\n\n// Internal function that returns an efficient (for current engines) version\n// of the passed-in callback, to be repeatedly applied in other Underscore\n// functions.\nfunction optimizeCb(func, context, argCount) {\n  if (context === void 0) return func;\n  switch (argCount == null ? 3 : argCount) {\n    case 1: return function(value) {\n      return func.call(context, value);\n    };\n    // The 2-argument case is omitted because we’re not using it.\n    case 3: return function(value, index, collection) {\n      return func.call(context, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(context, accumulator, value, index, collection);\n    };\n  }\n  return function() {\n    return func.apply(context, arguments);\n  };\n}\n\n// An internal function to generate callbacks that can be applied to each\n// element in a collection, returning the desired result — either `_.identity`,\n// an arbitrary callback, a property matcher, or a property accessor.\nfunction baseIteratee(value, context, argCount) {\n  if (value == null) return identity;\n  if (isFunction$1(value)) return optimizeCb(value, context, argCount);\n  if (isObject(value) && !isArray(value)) return matcher(value);\n  return property(value);\n}\n\n// External wrapper for our callback generator. Users may customize\n// `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n// This abstraction hides the internal-only `argCount` argument.\nfunction iteratee(value, context) {\n  return baseIteratee(value, context, Infinity);\n}\n_$1.iteratee = iteratee;\n\n// The function we call internally to generate a callback. It invokes\n// `_.iteratee` if overridden, otherwise `baseIteratee`.\nfunction cb(value, context, argCount) {\n  if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);\n  return baseIteratee(value, context, argCount);\n}\n\n// Returns the results of applying the `iteratee` to each element of `obj`.\n// In contrast to `_.map` it returns an object.\nfunction mapObject(obj, iteratee, context) {\n  iteratee = cb(iteratee, context);\n  var _keys = keys(obj),\n      length = _keys.length,\n      results = {};\n  for (var index = 0; index < length; index++) {\n    var currentKey = _keys[index];\n    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n  }\n  return results;\n}\n\n// Predicate-generating function. Often useful outside of Underscore.\nfunction noop(){}\n\n// Generates a function for a given object that returns a given property.\nfunction propertyOf(obj) {\n  if (obj == null) return noop;\n  return function(path) {\n    return get(obj, path);\n  };\n}\n\n// Run a function **n** times.\nfunction times(n, iteratee, context) {\n  var accum = Array(Math.max(0, n));\n  iteratee = optimizeCb(iteratee, context, 1);\n  for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n  return accum;\n}\n\n// Return a random integer between `min` and `max` (inclusive).\nfunction random(min, max) {\n  if (max == null) {\n    max = min;\n    min = 0;\n  }\n  return min + Math.floor(Math.random() * (max - min + 1));\n}\n\n// A (possibly faster) way to get the current timestamp as an integer.\nvar now = Date.now || function() {\n  return new Date().getTime();\n};\n\n// Internal helper to generate functions for escaping and unescaping strings\n// to/from HTML interpolation.\nfunction createEscaper(map) {\n  var escaper = function(match) {\n    return map[match];\n  };\n  // Regexes for identifying a key that needs to be escaped.\n  var source = '(?:' + keys(map).join('|') + ')';\n  var testRegexp = RegExp(source);\n  var replaceRegexp = RegExp(source, 'g');\n  return function(string) {\n    string = string == null ? '' : '' + string;\n    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n  };\n}\n\n// Internal list of HTML entities for escaping.\nvar escapeMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;'\n};\n\n// Function for escaping strings to HTML interpolation.\nvar _escape = createEscaper(escapeMap);\n\n// Internal list of HTML entities for unescaping.\nvar unescapeMap = invert(escapeMap);\n\n// Function for unescaping strings from HTML interpolation.\nvar _unescape = createEscaper(unescapeMap);\n\n// By default, Underscore uses ERB-style template delimiters. Change the\n// following template settings to use alternative delimiters.\nvar templateSettings = _$1.templateSettings = {\n  evaluate: /<%([\\s\\S]+?)%>/g,\n  interpolate: /<%=([\\s\\S]+?)%>/g,\n  escape: /<%-([\\s\\S]+?)%>/g\n};\n\n// When customizing `_.templateSettings`, if you don't want to define an\n// interpolation, evaluation or escaping regex, we need one that is\n// guaranteed not to match.\nvar noMatch = /(.)^/;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar escapes = {\n  \"'\": \"'\",\n  '\\\\': '\\\\',\n  '\\r': 'r',\n  '\\n': 'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction escapeChar(match) {\n  return '\\\\' + escapes[match];\n}\n\n// In order to prevent third-party code injection through\n// `_.templateSettings.variable`, we test it against the following regular\n// expression. It is intentionally a bit more liberal than just matching valid\n// identifiers, but still prevents possible loopholes through defaults or\n// destructuring assignment.\nvar bareIdentifier = /^\\s*(\\w|\\$)+\\s*$/;\n\n// JavaScript micro-templating, similar to John Resig's implementation.\n// Underscore templating handles arbitrary delimiters, preserves whitespace,\n// and correctly escapes quotes within interpolated code.\n// NB: `oldSettings` only exists for backwards compatibility.\nfunction template(text, settings, oldSettings) {\n  if (!settings && oldSettings) settings = oldSettings;\n  settings = defaults({}, settings, _$1.templateSettings);\n\n  // Combine delimiters into one regular expression via alternation.\n  var matcher = RegExp([\n    (settings.escape || noMatch).source,\n    (settings.interpolate || noMatch).source,\n    (settings.evaluate || noMatch).source\n  ].join('|') + '|$', 'g');\n\n  // Compile the template source, escaping string literals appropriately.\n  var index = 0;\n  var source = \"__p+='\";\n  text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n    index = offset + match.length;\n\n    if (escape) {\n      source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n    } else if (interpolate) {\n      source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n    } else if (evaluate) {\n      source += \"';\\n\" + evaluate + \"\\n__p+='\";\n    }\n\n    // Adobe VMs need the match returned to produce the correct offset.\n    return match;\n  });\n  source += \"';\\n\";\n\n  var argument = settings.variable;\n  if (argument) {\n    // Insure against third-party code injection. (CVE-2021-23358)\n    if (!bareIdentifier.test(argument)) throw new Error(\n      'variable is not a bare identifier: ' + argument\n    );\n  } else {\n    // If a variable is not specified, place data values in local scope.\n    source = 'with(obj||{}){\\n' + source + '}\\n';\n    argument = 'obj';\n  }\n\n  source = \"var __t,__p='',__j=Array.prototype.join,\" +\n    \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n    source + 'return __p;\\n';\n\n  var render;\n  try {\n    render = new Function(argument, '_', source);\n  } catch (e) {\n    e.source = source;\n    throw e;\n  }\n\n  var template = function(data) {\n    return render.call(this, data, _$1);\n  };\n\n  // Provide the compiled source as a convenience for precompilation.\n  template.source = 'function(' + argument + '){\\n' + source + '}';\n\n  return template;\n}\n\n// Traverses the children of `obj` along `path`. If a child is a function, it\n// is invoked with its parent as context. Returns the value of the final\n// child, or `fallback` if any child is undefined.\nfunction result(obj, path, fallback) {\n  path = toPath(path);\n  var length = path.length;\n  if (!length) {\n    return isFunction$1(fallback) ? fallback.call(obj) : fallback;\n  }\n  for (var i = 0; i < length; i++) {\n    var prop = obj == null ? void 0 : obj[path[i]];\n    if (prop === void 0) {\n      prop = fallback;\n      i = length; // Ensure we don't continue iterating.\n    }\n    obj = isFunction$1(prop) ? prop.call(obj) : prop;\n  }\n  return obj;\n}\n\n// Generate a unique integer id (unique within the entire client session).\n// Useful for temporary DOM ids.\nvar idCounter = 0;\nfunction uniqueId(prefix) {\n  var id = ++idCounter + '';\n  return prefix ? prefix + id : id;\n}\n\n// Start chaining a wrapped Underscore object.\nfunction chain(obj) {\n  var instance = _$1(obj);\n  instance._chain = true;\n  return instance;\n}\n\n// Internal function to execute `sourceFunc` bound to `context` with optional\n// `args`. Determines whether to execute a function as a constructor or as a\n// normal function.\nfunction executeBound(sourceFunc, boundFunc, context, callingContext, args) {\n  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n  var self = baseCreate(sourceFunc.prototype);\n  var result = sourceFunc.apply(self, args);\n  if (isObject(result)) return result;\n  return self;\n}\n\n// Partially apply a function by creating a version that has had some of its\n// arguments pre-filled, without changing its dynamic `this` context. `_` acts\n// as a placeholder by default, allowing any combination of arguments to be\n// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\nvar partial = restArguments(function(func, boundArgs) {\n  var placeholder = partial.placeholder;\n  var bound = function() {\n    var position = 0, length = boundArgs.length;\n    var args = Array(length);\n    for (var i = 0; i < length; i++) {\n      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n    }\n    while (position < arguments.length) args.push(arguments[position++]);\n    return executeBound(func, bound, this, this, args);\n  };\n  return bound;\n});\n\npartial.placeholder = _$1;\n\n// Create a function bound to a given object (assigning `this`, and arguments,\n// optionally).\nvar bind = restArguments(function(func, context, args) {\n  if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');\n  var bound = restArguments(function(callArgs) {\n    return executeBound(func, bound, context, this, args.concat(callArgs));\n  });\n  return bound;\n});\n\n// Internal helper for collection methods to determine whether a collection\n// should be iterated as an array or as an object.\n// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\nvar isArrayLike = createSizePropertyCheck(getLength);\n\n// Internal implementation of a recursive `flatten` function.\nfunction flatten$1(input, depth, strict, output) {\n  output = output || [];\n  if (!depth && depth !== 0) {\n    depth = Infinity;\n  } else if (depth <= 0) {\n    return output.concat(input);\n  }\n  var idx = output.length;\n  for (var i = 0, length = getLength(input); i < length; i++) {\n    var value = input[i];\n    if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {\n      // Flatten current level of array or arguments object.\n      if (depth > 1) {\n        flatten$1(value, depth - 1, strict, output);\n        idx = output.length;\n      } else {\n        var j = 0, len = value.length;\n        while (j < len) output[idx++] = value[j++];\n      }\n    } else if (!strict) {\n      output[idx++] = value;\n    }\n  }\n  return output;\n}\n\n// Bind a number of an object's methods to that object. Remaining arguments\n// are the method names to be bound. Useful for ensuring that all callbacks\n// defined on an object belong to it.\nvar bindAll = restArguments(function(obj, keys) {\n  keys = flatten$1(keys, false, false);\n  var index = keys.length;\n  if (index < 1) throw new Error('bindAll must be passed function names');\n  while (index--) {\n    var key = keys[index];\n    obj[key] = bind(obj[key], obj);\n  }\n  return obj;\n});\n\n// Memoize an expensive function by storing its results.\nfunction memoize(func, hasher) {\n  var memoize = function(key) {\n    var cache = memoize.cache;\n    var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n    if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);\n    return cache[address];\n  };\n  memoize.cache = {};\n  return memoize;\n}\n\n// Delays a function for the given number of milliseconds, and then calls\n// it with the arguments supplied.\nvar delay = restArguments(function(func, wait, args) {\n  return setTimeout(function() {\n    return func.apply(null, args);\n  }, wait);\n});\n\n// Defers a function, scheduling it to run after the current call stack has\n// cleared.\nvar defer = partial(delay, _$1, 1);\n\n// Returns a function, that, when invoked, will only be triggered at most once\n// during a given window of time. Normally, the throttled function will run\n// as much as it can, without ever going more than once per `wait` duration;\n// but if you'd like to disable the execution on the leading edge, pass\n// `{leading: false}`. To disable execution on the trailing edge, ditto.\nfunction throttle(func, wait, options) {\n  var timeout, context, args, result;\n  var previous = 0;\n  if (!options) options = {};\n\n  var later = function() {\n    previous = options.leading === false ? 0 : now();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n\n  var throttled = function() {\n    var _now = now();\n    if (!previous && options.leading === false) previous = _now;\n    var remaining = wait - (_now - previous);\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = _now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n\n  throttled.cancel = function() {\n    clearTimeout(timeout);\n    previous = 0;\n    timeout = context = args = null;\n  };\n\n  return throttled;\n}\n\n// When a sequence of calls of the returned function ends, the argument\n// function is triggered. The end of a sequence is defined by the `wait`\n// parameter. If `immediate` is passed, the argument function will be\n// triggered at the beginning of the sequence instead of at the end.\nfunction debounce(func, wait, immediate) {\n  var timeout, previous, args, result, context;\n\n  var later = function() {\n    var passed = now() - previous;\n    if (wait > passed) {\n      timeout = setTimeout(later, wait - passed);\n    } else {\n      timeout = null;\n      if (!immediate) result = func.apply(context, args);\n      // This check is needed because `func` can recursively invoke `debounced`.\n      if (!timeout) args = context = null;\n    }\n  };\n\n  var debounced = restArguments(function(_args) {\n    context = this;\n    args = _args;\n    previous = now();\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n      if (immediate) result = func.apply(context, args);\n    }\n    return result;\n  });\n\n  debounced.cancel = function() {\n    clearTimeout(timeout);\n    timeout = args = context = null;\n  };\n\n  return debounced;\n}\n\n// Returns the first function passed as an argument to the second,\n// allowing you to adjust arguments, run code before and after, and\n// conditionally execute the original function.\nfunction wrap(func, wrapper) {\n  return partial(wrapper, func);\n}\n\n// Returns a negated version of the passed-in predicate.\nfunction negate(predicate) {\n  return function() {\n    return !predicate.apply(this, arguments);\n  };\n}\n\n// Returns a function that is the composition of a list of functions, each\n// consuming the return value of the function that follows.\nfunction compose() {\n  var args = arguments;\n  var start = args.length - 1;\n  return function() {\n    var i = start;\n    var result = args[start].apply(this, arguments);\n    while (i--) result = args[i].call(this, result);\n    return result;\n  };\n}\n\n// Returns a function that will only be executed on and after the Nth call.\nfunction after(times, func) {\n  return function() {\n    if (--times < 1) {\n      return func.apply(this, arguments);\n    }\n  };\n}\n\n// Returns a function that will only be executed up to (but not including) the\n// Nth call.\nfunction before(times, func) {\n  var memo;\n  return function() {\n    if (--times > 0) {\n      memo = func.apply(this, arguments);\n    }\n    if (times <= 1) func = null;\n    return memo;\n  };\n}\n\n// Returns a function that will be executed at most one time, no matter how\n// often you call it. Useful for lazy initialization.\nvar once = partial(before, 2);\n\n// Returns the first key on an object that passes a truth test.\nfunction findKey(obj, predicate, context) {\n  predicate = cb(predicate, context);\n  var _keys = keys(obj), key;\n  for (var i = 0, length = _keys.length; i < length; i++) {\n    key = _keys[i];\n    if (predicate(obj[key], key, obj)) return key;\n  }\n}\n\n// Internal function to generate `_.findIndex` and `_.findLastIndex`.\nfunction createPredicateIndexFinder(dir) {\n  return function(array, predicate, context) {\n    predicate = cb(predicate, context);\n    var length = getLength(array);\n    var index = dir > 0 ? 0 : length - 1;\n    for (; index >= 0 && index < length; index += dir) {\n      if (predicate(array[index], index, array)) return index;\n    }\n    return -1;\n  };\n}\n\n// Returns the first index on an array-like that passes a truth test.\nvar findIndex = createPredicateIndexFinder(1);\n\n// Returns the last index on an array-like that passes a truth test.\nvar findLastIndex = createPredicateIndexFinder(-1);\n\n// Use a comparator function to figure out the smallest index at which\n// an object should be inserted so as to maintain order. Uses binary search.\nfunction sortedIndex(array, obj, iteratee, context) {\n  iteratee = cb(iteratee, context, 1);\n  var value = iteratee(obj);\n  var low = 0, high = getLength(array);\n  while (low < high) {\n    var mid = Math.floor((low + high) / 2);\n    if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n  }\n  return low;\n}\n\n// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.\nfunction createIndexFinder(dir, predicateFind, sortedIndex) {\n  return function(array, item, idx) {\n    var i = 0, length = getLength(array);\n    if (typeof idx == 'number') {\n      if (dir > 0) {\n        i = idx >= 0 ? idx : Math.max(idx + length, i);\n      } else {\n        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n      }\n    } else if (sortedIndex && idx && length) {\n      idx = sortedIndex(array, item);\n      return array[idx] === item ? idx : -1;\n    }\n    if (item !== item) {\n      idx = predicateFind(slice.call(array, i, length), isNaN$1);\n      return idx >= 0 ? idx + i : -1;\n    }\n    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n      if (array[idx] === item) return idx;\n    }\n    return -1;\n  };\n}\n\n// Return the position of the first occurrence of an item in an array,\n// or -1 if the item is not included in the array.\n// If the array is large and already in sort order, pass `true`\n// for **isSorted** to use binary search.\nvar indexOf = createIndexFinder(1, findIndex, sortedIndex);\n\n// Return the position of the last occurrence of an item in an array,\n// or -1 if the item is not included in the array.\nvar lastIndexOf = createIndexFinder(-1, findLastIndex);\n\n// Return the first value which passes a truth test.\nfunction find(obj, predicate, context) {\n  var keyFinder = isArrayLike(obj) ? findIndex : findKey;\n  var key = keyFinder(obj, predicate, context);\n  if (key !== void 0 && key !== -1) return obj[key];\n}\n\n// Convenience version of a common use case of `_.find`: getting the first\n// object containing specific `key:value` pairs.\nfunction findWhere(obj, attrs) {\n  return find(obj, matcher(attrs));\n}\n\n// The cornerstone for collection functions, an `each`\n// implementation, aka `forEach`.\n// Handles raw objects in addition to array-likes. Treats all\n// sparse array-likes as if they were dense.\nfunction each(obj, iteratee, context) {\n  iteratee = optimizeCb(iteratee, context);\n  var i, length;\n  if (isArrayLike(obj)) {\n    for (i = 0, length = obj.length; i < length; i++) {\n      iteratee(obj[i], i, obj);\n    }\n  } else {\n    var _keys = keys(obj);\n    for (i = 0, length = _keys.length; i < length; i++) {\n      iteratee(obj[_keys[i]], _keys[i], obj);\n    }\n  }\n  return obj;\n}\n\n// Return the results of applying the iteratee to each element.\nfunction map(obj, iteratee, context) {\n  iteratee = cb(iteratee, context);\n  var _keys = !isArrayLike(obj) && keys(obj),\n      length = (_keys || obj).length,\n      results = Array(length);\n  for (var index = 0; index < length; index++) {\n    var currentKey = _keys ? _keys[index] : index;\n    results[index] = iteratee(obj[currentKey], currentKey, obj);\n  }\n  return results;\n}\n\n// Internal helper to create a reducing function, iterating left or right.\nfunction createReduce(dir) {\n  // Wrap code that reassigns argument variables in a separate function than\n  // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n  var reducer = function(obj, iteratee, memo, initial) {\n    var _keys = !isArrayLike(obj) && keys(obj),\n        length = (_keys || obj).length,\n        index = dir > 0 ? 0 : length - 1;\n    if (!initial) {\n      memo = obj[_keys ? _keys[index] : index];\n      index += dir;\n    }\n    for (; index >= 0 && index < length; index += dir) {\n      var currentKey = _keys ? _keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    return memo;\n  };\n\n  return function(obj, iteratee, memo, context) {\n    var initial = arguments.length >= 3;\n    return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n  };\n}\n\n// **Reduce** builds up a single result from a list of values, aka `inject`,\n// or `foldl`.\nvar reduce = createReduce(1);\n\n// The right-associative version of reduce, also known as `foldr`.\nvar reduceRight = createReduce(-1);\n\n// Return all the elements that pass a truth test.\nfunction filter(obj, predicate, context) {\n  var results = [];\n  predicate = cb(predicate, context);\n  each(obj, function(value, index, list) {\n    if (predicate(value, index, list)) results.push(value);\n  });\n  return results;\n}\n\n// Return all the elements for which a truth test fails.\nfunction reject(obj, predicate, context) {\n  return filter(obj, negate(cb(predicate)), context);\n}\n\n// Determine whether all of the elements pass a truth test.\nfunction every(obj, predicate, context) {\n  predicate = cb(predicate, context);\n  var _keys = !isArrayLike(obj) && keys(obj),\n      length = (_keys || obj).length;\n  for (var index = 0; index < length; index++) {\n    var currentKey = _keys ? _keys[index] : index;\n    if (!predicate(obj[currentKey], currentKey, obj)) return false;\n  }\n  return true;\n}\n\n// Determine if at least one element in the object passes a truth test.\nfunction some(obj, predicate, context) {\n  predicate = cb(predicate, context);\n  var _keys = !isArrayLike(obj) && keys(obj),\n      length = (_keys || obj).length;\n  for (var index = 0; index < length; index++) {\n    var currentKey = _keys ? _keys[index] : index;\n    if (predicate(obj[currentKey], currentKey, obj)) return true;\n  }\n  return false;\n}\n\n// Determine if the array or object contains a given item (using `===`).\nfunction contains(obj, item, fromIndex, guard) {\n  if (!isArrayLike(obj)) obj = values(obj);\n  if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n  return indexOf(obj, item, fromIndex) >= 0;\n}\n\n// Invoke a method (with arguments) on every item in a collection.\nvar invoke = restArguments(function(obj, path, args) {\n  var contextPath, func;\n  if (isFunction$1(path)) {\n    func = path;\n  } else {\n    path = toPath(path);\n    contextPath = path.slice(0, -1);\n    path = path[path.length - 1];\n  }\n  return map(obj, function(context) {\n    var method = func;\n    if (!method) {\n      if (contextPath && contextPath.length) {\n        context = deepGet(context, contextPath);\n      }\n      if (context == null) return void 0;\n      method = context[path];\n    }\n    return method == null ? method : method.apply(context, args);\n  });\n});\n\n// Convenience version of a common use case of `_.map`: fetching a property.\nfunction pluck(obj, key) {\n  return map(obj, property(key));\n}\n\n// Convenience version of a common use case of `_.filter`: selecting only\n// objects containing specific `key:value` pairs.\nfunction where(obj, attrs) {\n  return filter(obj, matcher(attrs));\n}\n\n// Return the maximum element (or element-based computation).\nfunction max(obj, iteratee, context) {\n  var result = -Infinity, lastComputed = -Infinity,\n      value, computed;\n  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {\n    obj = isArrayLike(obj) ? obj : values(obj);\n    for (var i = 0, length = obj.length; i < length; i++) {\n      value = obj[i];\n      if (value != null && value > result) {\n        result = value;\n      }\n    }\n  } else {\n    iteratee = cb(iteratee, context);\n    each(obj, function(v, index, list) {\n      computed = iteratee(v, index, list);\n      if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {\n        result = v;\n        lastComputed = computed;\n      }\n    });\n  }\n  return result;\n}\n\n// Return the minimum element (or element-based computation).\nfunction min(obj, iteratee, context) {\n  var result = Infinity, lastComputed = Infinity,\n      value, computed;\n  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {\n    obj = isArrayLike(obj) ? obj : values(obj);\n    for (var i = 0, length = obj.length; i < length; i++) {\n      value = obj[i];\n      if (value != null && value < result) {\n        result = value;\n      }\n    }\n  } else {\n    iteratee = cb(iteratee, context);\n    each(obj, function(v, index, list) {\n      computed = iteratee(v, index, list);\n      if (computed < lastComputed || (computed === Infinity && result === Infinity)) {\n        result = v;\n        lastComputed = computed;\n      }\n    });\n  }\n  return result;\n}\n\n// Safely create a real, live array from anything iterable.\nvar reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\nfunction toArray(obj) {\n  if (!obj) return [];\n  if (isArray(obj)) return slice.call(obj);\n  if (isString(obj)) {\n    // Keep surrogate pair characters together.\n    return obj.match(reStrSymbol);\n  }\n  if (isArrayLike(obj)) return map(obj, identity);\n  return values(obj);\n}\n\n// Sample **n** random values from a collection using the modern version of the\n// [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n// If **n** is not specified, returns a single random element.\n// The internal `guard` argument allows it to work with `_.map`.\nfunction sample(obj, n, guard) {\n  if (n == null || guard) {\n    if (!isArrayLike(obj)) obj = values(obj);\n    return obj[random(obj.length - 1)];\n  }\n  var sample = toArray(obj);\n  var length = getLength(sample);\n  n = Math.max(Math.min(n, length), 0);\n  var last = length - 1;\n  for (var index = 0; index < n; index++) {\n    var rand = random(index, last);\n    var temp = sample[index];\n    sample[index] = sample[rand];\n    sample[rand] = temp;\n  }\n  return sample.slice(0, n);\n}\n\n// Shuffle a collection.\nfunction shuffle(obj) {\n  return sample(obj, Infinity);\n}\n\n// Sort the object's values by a criterion produced by an iteratee.\nfunction sortBy(obj, iteratee, context) {\n  var index = 0;\n  iteratee = cb(iteratee, context);\n  return pluck(map(obj, function(value, key, list) {\n    return {\n      value: value,\n      index: index++,\n      criteria: iteratee(value, key, list)\n    };\n  }).sort(function(left, right) {\n    var a = left.criteria;\n    var b = right.criteria;\n    if (a !== b) {\n      if (a > b || a === void 0) return 1;\n      if (a < b || b === void 0) return -1;\n    }\n    return left.index - right.index;\n  }), 'value');\n}\n\n// An internal function used for aggregate \"group by\" operations.\nfunction group(behavior, partition) {\n  return function(obj, iteratee, context) {\n    var result = partition ? [[], []] : {};\n    iteratee = cb(iteratee, context);\n    each(obj, function(value, index) {\n      var key = iteratee(value, index, obj);\n      behavior(result, value, key);\n    });\n    return result;\n  };\n}\n\n// Groups the object's values by a criterion. Pass either a string attribute\n// to group by, or a function that returns the criterion.\nvar groupBy = group(function(result, value, key) {\n  if (has$1(result, key)) result[key].push(value); else result[key] = [value];\n});\n\n// Indexes the object's values by a criterion, similar to `_.groupBy`, but for\n// when you know that your index values will be unique.\nvar indexBy = group(function(result, value, key) {\n  result[key] = value;\n});\n\n// Counts instances of an object that group by a certain criterion. Pass\n// either a string attribute to count by, or a function that returns the\n// criterion.\nvar countBy = group(function(result, value, key) {\n  if (has$1(result, key)) result[key]++; else result[key] = 1;\n});\n\n// Split a collection into two arrays: one whose elements all pass the given\n// truth test, and one whose elements all do not pass the truth test.\nvar partition = group(function(result, value, pass) {\n  result[pass ? 0 : 1].push(value);\n}, true);\n\n// Return the number of elements in a collection.\nfunction size(obj) {\n  if (obj == null) return 0;\n  return isArrayLike(obj) ? obj.length : keys(obj).length;\n}\n\n// Internal `_.pick` helper function to determine whether `key` is an enumerable\n// property name of `obj`.\nfunction keyInObj(value, key, obj) {\n  return key in obj;\n}\n\n// Return a copy of the object only containing the allowed properties.\nvar pick = restArguments(function(obj, keys) {\n  var result = {}, iteratee = keys[0];\n  if (obj == null) return result;\n  if (isFunction$1(iteratee)) {\n    if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n    keys = allKeys(obj);\n  } else {\n    iteratee = keyInObj;\n    keys = flatten$1(keys, false, false);\n    obj = Object(obj);\n  }\n  for (var i = 0, length = keys.length; i < length; i++) {\n    var key = keys[i];\n    var value = obj[key];\n    if (iteratee(value, key, obj)) result[key] = value;\n  }\n  return result;\n});\n\n// Return a copy of the object without the disallowed properties.\nvar omit = restArguments(function(obj, keys) {\n  var iteratee = keys[0], context;\n  if (isFunction$1(iteratee)) {\n    iteratee = negate(iteratee);\n    if (keys.length > 1) context = keys[1];\n  } else {\n    keys = map(flatten$1(keys, false, false), String);\n    iteratee = function(value, key) {\n      return !contains(keys, key);\n    };\n  }\n  return pick(obj, iteratee, context);\n});\n\n// Returns everything but the last entry of the array. Especially useful on\n// the arguments object. Passing **n** will return all the values in\n// the array, excluding the last N.\nfunction initial(array, n, guard) {\n  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n}\n\n// Get the first element of an array. Passing **n** will return the first N\n// values in the array. The **guard** check allows it to work with `_.map`.\nfunction first(array, n, guard) {\n  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];\n  if (n == null || guard) return array[0];\n  return initial(array, array.length - n);\n}\n\n// Returns everything but the first entry of the `array`. Especially useful on\n// the `arguments` object. Passing an **n** will return the rest N values in the\n// `array`.\nfunction rest(array, n, guard) {\n  return slice.call(array, n == null || guard ? 1 : n);\n}\n\n// Get the last element of an array. Passing **n** will return the last N\n// values in the array.\nfunction last(array, n, guard) {\n  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];\n  if (n == null || guard) return array[array.length - 1];\n  return rest(array, Math.max(0, array.length - n));\n}\n\n// Trim out all falsy values from an array.\nfunction compact(array) {\n  return filter(array, Boolean);\n}\n\n// Flatten out an array, either recursively (by default), or up to `depth`.\n// Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.\nfunction flatten(array, depth) {\n  return flatten$1(array, depth, false);\n}\n\n// Take the difference between one array and a number of other arrays.\n// Only the elements present in just the first array will remain.\nvar difference = restArguments(function(array, rest) {\n  rest = flatten$1(rest, true, true);\n  return filter(array, function(value){\n    return !contains(rest, value);\n  });\n});\n\n// Return a version of the array that does not contain the specified value(s).\nvar without = restArguments(function(array, otherArrays) {\n  return difference(array, otherArrays);\n});\n\n// Produce a duplicate-free version of the array. If the array has already\n// been sorted, you have the option of using a faster algorithm.\n// The faster algorithm will not work with an iteratee if the iteratee\n// is not a one-to-one function, so providing an iteratee will disable\n// the faster algorithm.\nfunction uniq(array, isSorted, iteratee, context) {\n  if (!isBoolean(isSorted)) {\n    context = iteratee;\n    iteratee = isSorted;\n    isSorted = false;\n  }\n  if (iteratee != null) iteratee = cb(iteratee, context);\n  var result = [];\n  var seen = [];\n  for (var i = 0, length = getLength(array); i < length; i++) {\n    var value = array[i],\n        computed = iteratee ? iteratee(value, i, array) : value;\n    if (isSorted && !iteratee) {\n      if (!i || seen !== computed) result.push(value);\n      seen = computed;\n    } else if (iteratee) {\n      if (!contains(seen, computed)) {\n        seen.push(computed);\n        result.push(value);\n      }\n    } else if (!contains(result, value)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n// Produce an array that contains the union: each distinct element from all of\n// the passed-in arrays.\nvar union = restArguments(function(arrays) {\n  return uniq(flatten$1(arrays, true, true));\n});\n\n// Produce an array that contains every item shared between all the\n// passed-in arrays.\nfunction intersection(array) {\n  var result = [];\n  var argsLength = arguments.length;\n  for (var i = 0, length = getLength(array); i < length; i++) {\n    var item = array[i];\n    if (contains(result, item)) continue;\n    var j;\n    for (j = 1; j < argsLength; j++) {\n      if (!contains(arguments[j], item)) break;\n    }\n    if (j === argsLength) result.push(item);\n  }\n  return result;\n}\n\n// Complement of zip. Unzip accepts an array of arrays and groups\n// each array's elements on shared indices.\nfunction unzip(array) {\n  var length = (array && max(array, getLength).length) || 0;\n  var result = Array(length);\n\n  for (var index = 0; index < length; index++) {\n    result[index] = pluck(array, index);\n  }\n  return result;\n}\n\n// Zip together multiple lists into a single array -- elements that share\n// an index go together.\nvar zip = restArguments(unzip);\n\n// Converts lists into objects. Pass either a single array of `[key, value]`\n// pairs, or two parallel arrays of the same length -- one of keys, and one of\n// the corresponding values. Passing by pairs is the reverse of `_.pairs`.\nfunction object(list, values) {\n  var result = {};\n  for (var i = 0, length = getLength(list); i < length; i++) {\n    if (values) {\n      result[list[i]] = values[i];\n    } else {\n      result[list[i][0]] = list[i][1];\n    }\n  }\n  return result;\n}\n\n// Generate an integer Array containing an arithmetic progression. A port of\n// the native Python `range()` function. See\n// [the Python documentation](https://docs.python.org/library/functions.html#range).\nfunction range(start, stop, step) {\n  if (stop == null) {\n    stop = start || 0;\n    start = 0;\n  }\n  if (!step) {\n    step = stop < start ? -1 : 1;\n  }\n\n  var length = Math.max(Math.ceil((stop - start) / step), 0);\n  var range = Array(length);\n\n  for (var idx = 0; idx < length; idx++, start += step) {\n    range[idx] = start;\n  }\n\n  return range;\n}\n\n// Chunk a single array into multiple arrays, each containing `count` or fewer\n// items.\nfunction chunk(array, count) {\n  if (count == null || count < 1) return [];\n  var result = [];\n  var i = 0, length = array.length;\n  while (i < length) {\n    result.push(slice.call(array, i, i += count));\n  }\n  return result;\n}\n\n// Helper function to continue chaining intermediate results.\nfunction chainResult(instance, obj) {\n  return instance._chain ? _$1(obj).chain() : obj;\n}\n\n// Add your own custom functions to the Underscore object.\nfunction mixin(obj) {\n  each(functions(obj), function(name) {\n    var func = _$1[name] = obj[name];\n    _$1.prototype[name] = function() {\n      var args = [this._wrapped];\n      push.apply(args, arguments);\n      return chainResult(this, func.apply(_$1, args));\n    };\n  });\n  return _$1;\n}\n\n// Add all mutator `Array` functions to the wrapper.\neach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n  var method = ArrayProto[name];\n  _$1.prototype[name] = function() {\n    var obj = this._wrapped;\n    if (obj != null) {\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) {\n        delete obj[0];\n      }\n    }\n    return chainResult(this, obj);\n  };\n});\n\n// Add all accessor `Array` functions to the wrapper.\neach(['concat', 'join', 'slice'], function(name) {\n  var method = ArrayProto[name];\n  _$1.prototype[name] = function() {\n    var obj = this._wrapped;\n    if (obj != null) obj = method.apply(obj, arguments);\n    return chainResult(this, obj);\n  };\n});\n\n// Named Exports\n\nvar allExports = {\n  __proto__: null,\n  VERSION: VERSION,\n  restArguments: restArguments,\n  isObject: isObject,\n  isNull: isNull,\n  isUndefined: isUndefined,\n  isBoolean: isBoolean,\n  isElement: isElement,\n  isString: isString,\n  isNumber: isNumber,\n  isDate: isDate,\n  isRegExp: isRegExp,\n  isError: isError,\n  isSymbol: isSymbol,\n  isArrayBuffer: isArrayBuffer,\n  isDataView: isDataView$1,\n  isArray: isArray,\n  isFunction: isFunction$1,\n  isArguments: isArguments$1,\n  isFinite: isFinite$1,\n  isNaN: isNaN$1,\n  isTypedArray: isTypedArray$1,\n  isEmpty: isEmpty,\n  isMatch: isMatch,\n  isEqual: isEqual,\n  isMap: isMap,\n  isWeakMap: isWeakMap,\n  isSet: isSet,\n  isWeakSet: isWeakSet,\n  keys: keys,\n  allKeys: allKeys,\n  values: values,\n  pairs: pairs,\n  invert: invert,\n  functions: functions,\n  methods: functions,\n  extend: extend,\n  extendOwn: extendOwn,\n  assign: extendOwn,\n  defaults: defaults,\n  create: create,\n  clone: clone,\n  tap: tap,\n  get: get,\n  has: has,\n  mapObject: mapObject,\n  identity: identity,\n  constant: constant,\n  noop: noop,\n  toPath: toPath$1,\n  property: property,\n  propertyOf: propertyOf,\n  matcher: matcher,\n  matches: matcher,\n  times: times,\n  random: random,\n  now: now,\n  escape: _escape,\n  unescape: _unescape,\n  templateSettings: templateSettings,\n  template: template,\n  result: result,\n  uniqueId: uniqueId,\n  chain: chain,\n  iteratee: iteratee,\n  partial: partial,\n  bind: bind,\n  bindAll: bindAll,\n  memoize: memoize,\n  delay: delay,\n  defer: defer,\n  throttle: throttle,\n  debounce: debounce,\n  wrap: wrap,\n  negate: negate,\n  compose: compose,\n  after: after,\n  before: before,\n  once: once,\n  findKey: findKey,\n  findIndex: findIndex,\n  findLastIndex: findLastIndex,\n  sortedIndex: sortedIndex,\n  indexOf: indexOf,\n  lastIndexOf: lastIndexOf,\n  find: find,\n  detect: find,\n  findWhere: findWhere,\n  each: each,\n  forEach: each,\n  map: map,\n  collect: map,\n  reduce: reduce,\n  foldl: reduce,\n  inject: reduce,\n  reduceRight: reduceRight,\n  foldr: reduceRight,\n  filter: filter,\n  select: filter,\n  reject: reject,\n  every: every,\n  all: every,\n  some: some,\n  any: some,\n  contains: contains,\n  includes: contains,\n  include: contains,\n  invoke: invoke,\n  pluck: pluck,\n  where: where,\n  max: max,\n  min: min,\n  shuffle: shuffle,\n  sample: sample,\n  sortBy: sortBy,\n  groupBy: groupBy,\n  indexBy: indexBy,\n  countBy: countBy,\n  partition: partition,\n  toArray: toArray,\n  size: size,\n  pick: pick,\n  omit: omit,\n  first: first,\n  head: first,\n  take: first,\n  initial: initial,\n  last: last,\n  rest: rest,\n  tail: rest,\n  drop: rest,\n  compact: compact,\n  flatten: flatten,\n  without: without,\n  uniq: uniq,\n  unique: uniq,\n  union: union,\n  intersection: intersection,\n  difference: difference,\n  unzip: unzip,\n  transpose: unzip,\n  zip: zip,\n  object: object,\n  range: range,\n  chunk: chunk,\n  mixin: mixin,\n  'default': _$1\n};\n\n// Default Export\n\n// Add all of the Underscore functions to the wrapper object.\nvar _ = mixin(allExports);\n// Legacy Node.js API.\n_._ = _;\n\nexports.VERSION = VERSION;\nexports._ = _;\nexports._escape = _escape;\nexports._unescape = _unescape;\nexports.after = after;\nexports.allKeys = allKeys;\nexports.before = before;\nexports.bind = bind;\nexports.bindAll = bindAll;\nexports.chain = chain;\nexports.chunk = chunk;\nexports.clone = clone;\nexports.compact = compact;\nexports.compose = compose;\nexports.constant = constant;\nexports.contains = contains;\nexports.countBy = countBy;\nexports.create = create;\nexports.debounce = debounce;\nexports.defaults = defaults;\nexports.defer = defer;\nexports.delay = delay;\nexports.difference = difference;\nexports.each = each;\nexports.every = every;\nexports.extend = extend;\nexports.extendOwn = extendOwn;\nexports.filter = filter;\nexports.find = find;\nexports.findIndex = findIndex;\nexports.findKey = findKey;\nexports.findLastIndex = findLastIndex;\nexports.findWhere = findWhere;\nexports.first = first;\nexports.flatten = flatten;\nexports.functions = functions;\nexports.get = get;\nexports.groupBy = groupBy;\nexports.has = has;\nexports.identity = identity;\nexports.indexBy = indexBy;\nexports.indexOf = indexOf;\nexports.initial = initial;\nexports.intersection = intersection;\nexports.invert = invert;\nexports.invoke = invoke;\nexports.isArguments = isArguments$1;\nexports.isArray = isArray;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isBoolean = isBoolean;\nexports.isDataView = isDataView$1;\nexports.isDate = isDate;\nexports.isElement = isElement;\nexports.isEmpty = isEmpty;\nexports.isEqual = isEqual;\nexports.isError = isError;\nexports.isFinite = isFinite$1;\nexports.isFunction = isFunction$1;\nexports.isMap = isMap;\nexports.isMatch = isMatch;\nexports.isNaN = isNaN$1;\nexports.isNull = isNull;\nexports.isNumber = isNumber;\nexports.isObject = isObject;\nexports.isRegExp = isRegExp;\nexports.isSet = isSet;\nexports.isString = isString;\nexports.isSymbol = isSymbol;\nexports.isTypedArray = isTypedArray$1;\nexports.isUndefined = isUndefined;\nexports.isWeakMap = isWeakMap;\nexports.isWeakSet = isWeakSet;\nexports.iteratee = iteratee;\nexports.keys = keys;\nexports.last = last;\nexports.lastIndexOf = lastIndexOf;\nexports.map = map;\nexports.mapObject = mapObject;\nexports.matcher = matcher;\nexports.max = max;\nexports.memoize = memoize;\nexports.min = min;\nexports.mixin = mixin;\nexports.negate = negate;\nexports.noop = noop;\nexports.now = now;\nexports.object = object;\nexports.omit = omit;\nexports.once = once;\nexports.pairs = pairs;\nexports.partial = partial;\nexports.partition = partition;\nexports.pick = pick;\nexports.pluck = pluck;\nexports.property = property;\nexports.propertyOf = propertyOf;\nexports.random = random;\nexports.range = range;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reject = reject;\nexports.rest = rest;\nexports.restArguments = restArguments;\nexports.result = result;\nexports.sample = sample;\nexports.shuffle = shuffle;\nexports.size = size;\nexports.some = some;\nexports.sortBy = sortBy;\nexports.sortedIndex = sortedIndex;\nexports.tap = tap;\nexports.template = template;\nexports.templateSettings = templateSettings;\nexports.throttle = throttle;\nexports.times = times;\nexports.toArray = toArray;\nexports.toPath = toPath$1;\nexports.union = union;\nexports.uniq = uniq;\nexports.uniqueId = uniqueId;\nexports.unzip = unzip;\nexports.values = values;\nexports.where = where;\nexports.without = without;\nexports.wrap = wrap;\nexports.zip = zip;\n//# sourceMappingURL=underscore-node-f.cjs.map\n","//     Underscore.js 1.13.6\n//     https://underscorejs.org\n//     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\nvar underscoreNodeF = require('./underscore-node-f.cjs');\n\n\n\nmodule.exports = underscoreNodeF._;\n//# sourceMappingURL=underscore-node.cjs.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst avrolint = require('./avrolint');\n\nasync function run() {\n  try {\n    // 'avsc-to-lint' input defined in action metadata file\n    const avscToLint = core.getInput('avsc-to-lint', {required: true});\n    const undocumentedCheck = core.getInput(\n      'undocumented-field-check',\n      {required: true}\n    );\n\t\tconst complexUnionCheck = core.getInput(\n      'complex-union-check',\n      {required: true}\n    );\n    console.log(`Linting ${avscToLint}!`);\n    await avrolint(\n      avscToLint,\n\t\t\t{\n        \"undocumentedCheck\": undocumentedCheck,\n        \"complexUnionCheck\": complexUnionCheck\n\t\t\t}\n    );\n  } catch (error) {\n    console.error(error.stack);\n    core.setFailed(error.message);\n  }\n}\n\nrun();\n"],"names":[],"sourceRoot":""}