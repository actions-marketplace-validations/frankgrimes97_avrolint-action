{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9KA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../avrolint.js","../../../../../usr/local/Cellar/ncc/0.36.1/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../node:node-commonjs \"fs\"","/webpack/bootstrap","/webpack/runtime/compat","../index.js"],"sourcesContent":["const fs = require('fs')\nconst core = require('@actions/core');\nconst avro = require('avro-js');\n\nlet avrolint = function(avscFilePath, options={\"undocumentedCheck\": true, \"complexUnionCheck\": true}) {\n  return new Promise((resolve) => {\n    // default, assume input is single file\n    var filePaths = [avscFilePath];\n    try {\n      // try to see if it's a list of paths in JSON array\n      filePaths = JSON.parse(avscFilePath);\n    }\n    catch (err) {\n      // ignore\n    }\n\n    var filePathsWithErrors = new Set();\n    for (const filePath of filePaths) {\n      if (typeof filePath === 'undefined' || !fs.existsSync(filePath)) {\n        if (typeof filePath === 'undefined') {\n          filePathsWithErrors.add(\"undefined\"); // without this a blank error message is printed\n        } else {\n          filePathsWithErrors.add(filePath);\n        }\n        core.error(\"avscFilePath is invalid: '\" + filePath + \"'\");\n        continue;\n      }\n\n      var fileContents = fs.readFileSync(filePath);\n      var avroSchemaJson;\n\n      try {\n        avroSchemaJson = JSON.parse(fileContents);\n      } catch (err) {\n        filePathsWithErrors.add(filePath);\n        core.error(\"AVSC file specified is not valid/parseable JSON: \" + filePath + \"\\n  \" + err.toString());\n        continue;\n      }\n\n      var avroType;\n      try {\n        avroType = avro.parse(avroSchemaJson);\n      } catch (err) {\n        filePathsWithErrors.add(filePath);\n        core.error(\"AVSC file specified is not valid/parseable: \" + filePath + \"\\n  \" + err.toString());\n        continue;\n      }\n\n      if (options.undocumentedCheck) {\n        const undocumentedFields = getUndocumentedFields(avroType.getName(), avroSchemaJson);\n        if (undocumentedFields.length > 0) {\n          filePathsWithErrors.add(filePath);\n          const errorMessage = `Invalid Schema at '${filePath}'! The following fields are not documented:`;\n          core.error(errorMessage.concat(\"\\n  \", ...undocumentedFields.join(\"\\n  \")));\n        }\n      }\n\n      if (options.complexUnionCheck) {\n        const complexUnionFields = getComplexUnionFields(avroType.getName(), avroSchemaJson);\n        if (complexUnionFields.length > 0) {\n          filePathsWithErrors.add(filePath);\n          const errorMessage = `Invalid Schema at '${filePath}'! The following fields are or contain complex unions:`;\n          core.error(errorMessage.concat(\"\\n  \", ...complexUnionFields.join(\"\\n  \")));\n        }\n      }\n    }\n\n    if (filePathsWithErrors.size > 0) {\n      const errorMessage = \"Validation failed for the following files:\";\n      throw new Error(errorMessage.concat(\"\\n  \", ...Array.from(filePathsWithErrors.keys()).join(\"\\n  \")));\n    }\n\n    resolve(\"done!\");\n  });\n};\n\nlet isOrContainsRecord = function(field) {\n  if (Array.isArray(field.type)) {\n    // Check UNION type for RECORD type\n    return field.type.filter(x => x.type?.toUpperCase() === \"RECORD\").length > 0;\n  }\n\n  const upperCaseFieldType = field.type.type?.toUpperCase();\n  if (upperCaseFieldType === \"RECORD\") {\n    return true;\n  } else if (upperCaseFieldType === \"ARRAY\" && field.type.items?.type?.toUpperCase() === \"RECORD\") {\n    return true;\n  } else if (upperCaseFieldType === \"MAP\" && field.type.values?.type?.toUpperCase() === \"RECORD\") {\n    return true;\n  }\n\n  return false;\n}\n\nlet isUnionType = function(type) {\n  return Array.isArray(type);\n}\n\nlet getRecordSchema = function(field) {\n  if (isUnionType(field.type)) {\n    // Extract UNION type RECORD schema\n    return field.type.filter(x => x.type?.toUpperCase() === \"RECORD\")[0];\n  }\n\n  const upperCaseFieldType = field.type.type?.toUpperCase();\n  if (upperCaseFieldType === \"RECORD\") {\n    return field.type;\n  } else if (upperCaseFieldType === \"ARRAY\" && field.type.items?.type?.toUpperCase() === \"RECORD\") {\n    return field.type.items;\n  } else if (upperCaseFieldType === \"MAP\" && field.type.values?.type?.toUpperCase() === \"RECORD\") {\n    return field.type.values;\n  }\n}\n\nlet getUndocumentedFields = function(pathPrefix, avroSchemaJson) {\n  const undocumentedFields = [];\n\n  for (const field of avroSchemaJson.fields) {\n    if (field.doc == null || field.doc.trim() === '') {\n      undocumentedFields.push(pathPrefix + '.' + field.name);\n    }\n    if (isOrContainsRecord(field)) {\n      undocumentedFields.push(...getUndocumentedFields(pathPrefix + '.' + field.name, getRecordSchema(field)));\n    }\n  }\n\n  return undocumentedFields;\n}\n\nlet getUnionSchema = function(field) {\n  if (isUnionType(field.type)) {\n    return field.type;\n  }\n\n  const upperCaseFieldType = field.type.type?.toUpperCase();\n  if (upperCaseFieldType === \"ARRAY\" && isUnionType(field.type.items)) {\n    return field.type.items;\n  } else if (upperCaseFieldType === \"MAP\" && isUnionType(field.type.values)) {\n     return field.type.values;\n  }\n\n}\n\nlet isComplexUnion = function(field) {\n  const unionSchema = getUnionSchema(field);\n\n  if (!unionSchema) {\n    return false;\n  }\n\n  if (unionSchema.length == 2 && unionSchema[0].toUpperCase() === \"NULL\") {\n    return false;\n  }\n\n return true;\n}\n\nlet getComplexUnionFields = function(pathPrefix, avroSchemaJson) {\n  const complexUnionFields = [];\n\n  for (const field of avroSchemaJson.fields) {\n    if (isComplexUnion(field)) {\n      complexUnionFields.push(pathPrefix + '.' + field.name);\n    }\n\n    if (isOrContainsRecord(field)) {\n      complexUnionFields.push(...getComplexUnionFields(pathPrefix + '.' + field.name, getRecordSchema(field)));\n    }\n  }\n\n  return complexUnionFields;\n}\n\nmodule.exports = avrolint;\n\n",null,"module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst avrolint = require('./avrolint');\n\nasync function run() {\n  try {\n    // 'avsc-to-lint' input defined in action metadata file\n    const avscToLint = core.getInput('avsc-to-lint', {required: true});\n    const undocumentedCheck = core.getBooleanInput(\n      'undocumented-field-check',\n      {required: true}\n    );\n    const complexUnionCheck = core.getBooleanInput(\n      'complex-union-check',\n      {required: true}\n    );\n    console.log(`Linting ${avscToLint}!`);\n    await avrolint(\n      avscToLint,\n      {\n        \"undocumentedCheck\": undocumentedCheck,\n        \"complexUnionCheck\": complexUnionCheck\n      }\n    );\n  } catch (error) {\n    console.error(error.stack);\n    core.setFailed(error.message);\n  }\n}\n\nrun();\n"],"names":[],"sourceRoot":""}